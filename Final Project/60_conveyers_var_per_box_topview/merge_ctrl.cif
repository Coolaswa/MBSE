/*  MergeControl is a controller that coordinates/merges the product flows of two upstream conveyers
    (from conveyer "zero" and conveyer "one") into a downstream conveyer.
    There is no corresponding merging conveyer.
    The stream of one of the upstream conveyers is allowed to proceed to the downstream conveyer.
*/
group def MergeControl(
    alg bool
        // parameters from conveyer zero
        reset_ES_from_prev_0,   // Request from downstream conveyer zero to upstream conveyer to reset Energy Save
        prev_R2S_0,             // R2S status of downstream conveyer zero

        // parameters from conveyer one
        reset_ES_from_prev_1,   // see above
        prev_R2S_1,             // see above

        prev_TIP,   /*  Corresponding argument should be the disjunction of the two TIPs of the upstream conveyers.
                        Only one of the two conveyers can have TIP = true, and we do not need the two individual TIPs.
                    */
        next_R2R    // R2R status of upstream conveyer
    ):

    // Signals for the two upstream conveyers
    alg bool R2R_zero       = discrete.R2R and policy.zero; // Ready To Receive for conveyer "zero"
    alg bool R2R_one        = discrete.R2R and policy.one;  // Ready To Recieve for conveyer "one"

    // Energy Save Reset request for upstream conveyer
    alg bool next_reset_ES  = if policy.zero: reset_ES_from_prev_0 else reset_ES_from_prev_1 end;

    // Signals for downstream conveyer
    alg bool TIP            = discrete.TIP;                 // Transaction In Progress
    alg bool R2S            = discrete.R2S;                 // Ready/Request To Send


    /****************************** private ******************************/

    alg bool alg_TIP = prev_TIP;
    alg bool alg_R2S = if policy.zero: prev_R2S_0 else prev_R2S_1 end;
    alg bool alg_R2R = next_R2R;

    /*  Define which of the two incoming conveyer streams ("zero" or "one" is connected to the outgoing conveyer */
    automaton policy:
        // private
        event toOne, toZero;
        cont t = switch_time der -1;
        const real switch_time = 12;

        alg bool to_zero = not prev_R2S_1 and (prev_R2S_0 or
                                                (reset_ES_from_prev_0 and not reset_ES_from_prev_1));
        alg bool to_one  = not prev_R2S_0 and (prev_R2S_1 or
                                                (reset_ES_from_prev_1 and not reset_ES_from_prev_0));

        location zero:
            initial;
            edge toOne  when not alg_TIP and t <= 0     do t:= switch_time goto one;
            edge toOne  when not alg_TIP and to_one     do t:= switch_time goto one;

        location one:
            edge toZero when not alg_TIP and t <= 0     do t:= switch_time goto zero;
            edge toZero when not alg_TIP and to_zero    do t:= switch_time goto zero;
    end

    /*  Break algebraic loop for R2R and R2S.
        Also introduce discrete var for TIP, because TIP and R2S must be synchronized, e.g:
        when myR2S and myTIP simultaneously become true, then TIP and R2S, also must become
        true simultaneously, so that an intermediate state such as R2S = false and TIP = true
        cannot occur.
    */
    automaton discrete:
        disc bool R2R = false;
        disc bool R2S = false;
        disc bool TIP = false;

        event sync_R2R, sync_R2S; // private

        location:
            initial;
            edge sync_R2R when R2R != alg_R2R                   do R2R := alg_R2R;
            edge sync_R2S when R2S != alg_R2S or TIP != alg_TIP do R2S := alg_R2S, TIP := alg_TIP;
    end

end

