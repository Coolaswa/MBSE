import "testing_buffering_station_svg.cif";

alg bool s_Tstartbutton = startBttn.state;
alg bool s_Tstopbutton = startBttn.state;
//alg bool s_Tautoswitch;
alg bool s_Tresetbutton = startBttn.state;
alg bool a_elevator_up = LiftContr.Up;
alg bool a_elevator_down = LiftContr.Down;
alg bool a_pusher = PusherContr.Extending;

event startClicked, stopClicked, resetClicked, dummyEvent;
event lift_up_clicked, lift_down_clicked;
event pusher_clicked;

startBttn: Button(startClicked);
start_svg: Button_svg(startClicked, "start", "yellow", "grey",  startBttn.state);

stopBttn: Button(stopClicked);
stop_svg: Button_svg(stopClicked, "stop", "yellow", "grey",  stopBttn.state);
//resetBttn: Button(e_resetClicked);

svg_s_lift_up: Button_svg(dummyEvent, "s_lift_up", "yellow", "grey", LiftSensorUp.isActive);
svg_s_lift_down: Button_svg(dummyEvent, "s_lift_down", "yellow", "grey", LiftSensorDown.isActive);

b_lift_up: Button(lift_up_clicked);
svg_a_lift_up: Button_svg(lift_up_clicked, "a_lift_up", "yellow", "grey", b_lift_up.state);

b_lift_down: Button(lift_down_clicked);
svg_a_lift_down: Button_svg(lift_down_clicked, "a_lift_down", "yellow", "grey", b_lift_down.state);

b_pusher: Button(pusher_clicked);
svg_b_pusher: Button_svg(pusher_clicked, "b_pusher", "yellow", "grey", b_pusher.state);
svg_s_pusher: Button_svg(dummyEvent, "s_pusher", "yellow", "grey", PusherSensor.isActive);

svg_s_height: Button_svg(dummyEvent, "s_height", "yellow", "grey", HeightSensor.isActive);


type BoxStatData = tuple(int height; bool isCapacitive);
type BoxDynData = tuple(real speedX, speedY);
type Point = tuple(real x, y);

const BoxDynData upData = (0,-10);
const BoxDynData stopData = (0,0);
const BoxDynData downData = (0,10);

box1: Box(35, true);

automaton dummy:
	location:
		initial;
		edge dummyEvent when false;
end

automaton BoxUpdater:
	alg list[3] BoxDynData data;
	location:
		equation data = [(box1.x,box1.y), (1,1), (2,2)];
		initial;

end

func bool Collision(Point topLeft, botRight, p1; list BoxDynData stuffs):
	int i = 0;
	int length = size(stuffs);
	bool result = false;
	while i < length:
		if (topLeft[x] <= p1[x] and topLeft[y] <= p1[y] and
			botRight[x] >= p1[x] and botRight[y] >= p1[y]):
			result := true;
		end
		i := i + 1;
	end

	return result;
end

automaton def Box(alg int height; alg bool isCapacitive):
alg BoxStatData statData = (height, isCapacitive);
disc BoxDynData dynData = (0, 0);
cont x, y;
	location InLift:
		initial;
		equation x' = 0;
		equation y' = Lift.speed;
end

automaton def Button(event Clicked):
	alg bool state;

	location Released:
		initial;
		equation state = false;
		edge Clicked goto Pressed;
	location Pressed:
		equation state = true;
		edge Clicked goto Released;
end


automaton Lift:
	alg real speed;
	cont y der speed;
	location Up:
		equation speed = 10;
		edge when not a_elevator_up goto Stop;
		edge when a_elevator_down goto Down;
		edge when LiftSensorUp.isActive goto Stop;
	location Stop:
		initial;
		equation speed = 0;
		edge when a_elevator_up and not LiftSensorUp.isActive goto Up;
		edge when a_elevator_down and not LiftSensorDown.isActive  goto Down;
	location Down:
		equation speed = -10;
		edge when not a_elevator_down goto Stop;
		edge when a_elevator_up goto Up;
		edge when LiftSensorDown.isActive goto Stop;
end

automaton Pusher:
	alg real speed;
	cont x der speed;
	location Extending:
		equation speed = if not PusherSensor.isActive: -20 else 0 end;
		edge when not a_pusher goto Retracting;
	location Retracting:
		initial;
		equation speed = if x < 0: 20 else 0 end;
		edge when a_pusher goto Extending;
end

group LiftSensorUp:
	alg bool isActive = Lift.y >= 62;
end

group LiftSensorDown:
	alg bool isActive = Lift.y <= 0;
end

group PusherSensor:
	alg bool isActive = Pusher.Extending and Pusher.x < -35;
end

group HeightSensor:
	alg bool isActive = Collision((0,0), (100,box1.y), (50,42), BoxUpdater.data);
end
