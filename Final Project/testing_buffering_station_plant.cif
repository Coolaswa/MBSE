import "testing_buffering_station_svg.cif";
import "Defs.cif";
import "SVGConstants.cif";

alg bool s_Tstartbutton = startBttn.state;
alg bool s_Tstopbutton = startBttn.state;

//alg bool s_Tautoswitch;
alg bool s_Tresetbutton = startBttn.state;
alg bool a_elevator_up = (ctrl.Lift.state = UP);
alg bool a_elevator_down = (ctrl.Lift.state = DOWN);
alg bool a_pusher = ctrl.PusherContr.Extending;
alg bool s_pusher = PusherSensor.isActive;
alg bool s_elevator_up = LiftSensorUp.isActive;
alg bool s_elevator_down = LiftSensorDown.isActive;
alg bool a_conveyer = ConveyerContr.Moving;
alg bool a_separator = SeparatorContr.FullLeft;

event e_startClicked, stopClicked, resetClicked, dummyEvent;
event lift_up_clicked, lift_down_clicked;
event pusher_clicked;
event spawn_clicked;
event void spawn_new_block;

startBttn: Button(e_startClicked);
start_svg: Button_svg(e_startClicked, "start", "yellow", "grey",  startBttn.state);

stopBttn: Button(stopClicked);
stop_svg: Button_svg(stopClicked, "stop", "yellow", "grey",  stopBttn.state);
//resetBttn: Button(resetClicked);

svg_s_lift_up: Button_svg(dummyEvent, "s_lift_up", "yellow", "grey", LiftSensorUp.isActive);
svg_s_lift_down: Button_svg(dummyEvent, "s_lift_down", "yellow", "grey", LiftSensorDown.isActive);

b_lift_up: Button(lift_up_clicked);
svg_a_lift_up: Button_svg(lift_up_clicked, "a_lift_up", "yellow", "grey", b_lift_up.state);

b_lift_down: Button(lift_down_clicked);
svg_a_lift_down: Button_svg(lift_down_clicked, "a_lift_down", "yellow", "grey", b_lift_down.state);

b_pusher: Button(pusher_clicked);
svg_b_pusher: Button_svg(pusher_clicked, "b_pusher", "yellow", "grey", b_pusher.state);
svg_s_pusher: Button_svg(dummyEvent, "s_pusher", "yellow", "grey", PusherSensor.isActive);

svg_s_height: Button_svg(dummyEvent, "s_height", "yellow", "grey", HeightSensor.isActive);
svg_s_capacitive: Button_svg(dummyEvent, "s_capacitive", "yellow", "grey", CapacitiveSensor.isActive);
b_spawn: Button(spawn_clicked);
svg_b_spawn: Button_svg(spawn_clicked, "b_spawn", "yellow", "grey", b_spawn.state);

event void e_pusher_activated;

box1: Box(35, true);
svg_box1 : Box_svg("Product1", box1.x, box1.y, box1.rotation, box1.opacity);
box2: Box(35, true);
svg_box2 : Box_svg("Product2", box2.x, box2.y, box2.rotation, box2.opacity);
box3: Box(35, true);
svg_box3 : Box_svg("Product3", box3.x, box3.y, box3.rotation, box3.opacity);

conv1: Conveyor();

automaton dummy:
	location:
		initial;
		edge dummyEvent when false;
end

automaton BoxUpdater:
	alg list[3] BoxData data;
	alg list[3] Rectangle rects;
	location:
		equation data = [
		 ((box1.x,box1.y,50,50), true),
		 ((box2.x,box2.y,50,50), false),
		 ((box3.x,box3.y,50,50), false)];
		 equation rects = [
		 (box1.x,box1.y,50,50),
		 (box2.x,box2.y,50,50),
		 (box3.x,box3.y,50,50)];
		initial;
end

const real boxSpeed = 60;
automaton def Box(alg int h; alg bool isCap):
	alg int height = h;
	alg real slideAngle = (15)*3.141592654/180;
	alg bool isCapacitive = isCap;
	disc real opacityDer = 0;
	disc real rotDer = 0;

	cont rotation = 0 der rotDer;
	cont opacity der opacityDer;
	cont x = -200, y=-200;
	location Inactive:
		equation x' = 0, y' = 0;
		initial;
		edge spawn_new_block? do (x,y) := Const.Box.StartPos,opacity:=1  goto Spawn;
	location Spawn:
		equation x' = 0, y' = 0;
		edge when opacity > 0.995 do opacityDer := 0 goto InLift;
	location InLift:
		equation x' = 0, y' = Lift.speed;
		edge e_pusher_activated? when LiftSensorUp.isActive do rotDer := -30 goto LiftAirTransit;
	location LiftAirTransit:
		equation x' = -boxSpeed*cos(slideAngle), y' = boxSpeed*sin(slideAngle);
		edge when rotation < -15 do rotDer := 0 goto OnAirslide;
	location OnAirslide:
		equation x' = -boxSpeed*cos(slideAngle), y' = boxSpeed*sin(slideAngle);
		edge when y > Const.Box.BufferY do rotDer := boxSpeed goto SlideBufferTransit;
	location SlideBufferTransit:
		equation x' = -boxSpeed, y' = 0;
		edge when rotation > 0 do rotDer := 0 goto OnBuffer;
	location OnBuffer:
		equation x' = -boxSpeed, y' = 0;
		edge when x < 0 goto Inactive;
end

automaton def Conveyor():
	event turnOn, turnOff;
	event toggle;
	cont wheelRotation der -boxSpeed;
	alg real wheelSpeed;
	location On:
		initial;
		equation wheelSpeed = 50/20/3.1415;
		//edge turnOff, toggle goto Off;
		//edge turnOn;
	location Off:
		equation wheelSpeed = 0;
		edge turnOn, toggle goto On;
		edge turnOff;
end

automaton Lift:
	const real maxSpeed = 80;
	alg real speed;
	cont y der speed;
	location Up:
		equation speed = -maxSpeed;
		edge when not a_elevator_up goto Stop;
		edge when a_elevator_down goto Down;
		edge when LiftSensorUp.isActive goto Stop;
	location Stop:
		initial;
		equation speed = 0;
		edge when a_elevator_up and not LiftSensorUp.isActive goto Up;
		edge when a_elevator_down and not LiftSensorDown.isActive  goto Down;
	location Down:
		equation speed = maxSpeed;
		edge when not a_elevator_down goto Stop;
		edge when a_elevator_up goto Up;
		edge when LiftSensorDown.isActive goto Stop;
end

automaton Pusher:
	alg real speed;
	cont x der speed;
	location Extending:
		equation speed = if not PusherSensor.isActive: -20 else 0 end;
		edge when not a_pusher goto Retracting;
	location Retracting:
		initial;
		equation speed = if x < 0: 20 else 0 end;
		edge e_pusher_activated! when a_pusher goto Extending;
end

group LiftSensorUp:
	alg bool isActive = Lift.y <= -Const.Lift.MaxHeight;
end

group LiftSensorDown:
	alg bool isActive = Lift.y >= 0;
end

group PusherSensor:
	alg bool isActive = Pusher.Extending and Pusher.x < -35;
end

automaton HeightSensor:
	alg bool isActive = RectRectColl(Const.Sensors.HeightBounds, BoxUpdater.rects) != -1;
	cont y;
	location:
		equation y' = if isActive: Lift.speed elif y < 0: 10 else 0 end;
		initial;
end

group CapacitiveSensor:
	alg int boxI = RectRectColl((Const.Sensors.CapSensorBounds[x],
	 							Const.Sensors.CapSensorBounds[y] + Lift.y,
	  							Const.Sensors.CapSensorBounds[width],
	   							Const.Sensors.CapSensorBounds[height]), BoxUpdater.rects);
	alg bool isActive = boxI != -1 and BoxUpdater.data[boxI][isCap];
end

automaton Factory:
	location Waiting:
		initial;
		edge spawn_clicked goto SpawnBlock;
	location SpawnBlock:
		edge spawn_new_block! goto Waiting;
end

//Buffering station

//separator functions:

//a_separator = on -> Receive one new product ----- always receive a new product after releasing one
//a_separator = off ->  Release the current product ----- If processing is not busy
//a_conveyer = on -> Conveyer belt  ----- after releasing a product
//a_conveyer = off -> Conveyer belt ----- Always off unless ^

//s_processingbusy = on -> Busy
//s_processingbusy = off -> Ready
//s_atseparator = on -> Product just before separator

//Max of 5 products functions:

//s_product = on -> product at entry point ----- Use this to count up to 5, if 5 then stop testing station pusher or lift
//s_atexit = on -> Product leaving buffering station


//sensors still have to be fixed to work with multiple boxes and add the right x value

group AtSepSensor:
	alg bool isActive = box1.x = 300; // Location sensor = ???,
end

group EntrySensor:
	alg bool isActive = box1.x = 600; // Location sensor = ???
end

group ExitSensor:
	alg bool isActive = box1.x = 200; // Location sensor = ???
end

automaton ProcessingBusySensor: // timed activation every 15 seconds, eventually use s_processingbusy
	cont t der 1;
	location Off:
		edge when t > 15 do t := 0 goto On;
	location On:
	initial;
		edge when t < 15 goto Off;
end


automaton Belt:			// add fancy part with svg belt turning
	alg real speed;
	cont x der speed;
	location Moving:
		equation speed = -20;
		edge when not a_conveyer goto Standstill;
	location Standstill:
		initial;
		equation speed = 0;
		edge when a_conveyer goto Moving;
end

automaton Separator:	//Separator needs to turn/rotate when going from left to right, to be added
	location Left:
		edge when not a_separator goto Right;
	location Right:
		initial;
		edge when a_separator goto Left;
end

automaton CountFive:	//when CountFive = 5, stops the pusher; see control
	location Zero:
		initial;
		edge when EntrySensor.isActive goto One;
	location One:
		edge when ExitSensor.isActive goto Zero;
		edge when EntrySensor.isActive goto Two;
	location Two:
		edge when ExitSensor.isActive goto One;
		edge when EntrySensor.isActive goto Three;
	location Three:
		edge when ExitSensor.isActive goto Two;
		edge when EntrySensor.isActive goto Four;
	location Four:
		edge when ExitSensor.isActive goto Three;
		edge when EntrySensor.isActive goto Five;
	location Five:
		edge when ExitSensor.isActive goto Four;
end


