// Controller to test hardware mapping, for all sensors and actuators.
import "testing_buffering_station_plant.cif";

automaton Coordinator:
    alg LiftState liftState;
    alg bool pusherExtending;
    alg bool busy;
    location ManualMode:
        //initial;
        equation liftState = ManualControl.Lift.state;
        equation pusherExtending = ManualControl.PusherContr.Extending;
        equation busy = false;
    location AutoMode:
        initial;
        equation liftState = AutoControl.Lift.state;
        equation pusherExtending = AutoControl.PusherContr.Extending;
        equation busy = not AutoControl.Lift.Waiting;
end

enum LiftState = UP, STOP, DOWN;
group ManualControl:
	automaton Lift:
		alg LiftState state;
		location Up:
			equation state = UP;
			edge when b_lift_up.Released goto Stop;
			edge when b_lift_down.Pressed and b_lift_up.Released goto Down;
		location Stop:
			initial;
			equation state = STOP;
			edge when b_lift_up.Pressed goto Up;
			edge when b_lift_down.Pressed goto Down;
		location Down:
			equation state = DOWN;
			edge when b_lift_up.Pressed and b_lift_down.Released  goto Up;
			edge when b_lift_down.Released goto Stop;
	end

	automaton PusherContr:
		location Extending:
			edge when b_pusher.Released goto Retracting;
		location Retracting:
			initial;
			edge when CountFive.Five goto Lockdown;		//Pusher will not push when the buffer is full
			edge when b_pusher.Pressed goto Extending;
		location Lockdown:
			edge when CountFive.Four goto Retracting;
	end
end
event b_case1Pressed, b_case2Pressed, b_case3Pressed;
b_case1: Button(b_case1Pressed);
b_case1_svg: Button_svg(b_case1Pressed, "b_case1", "yellow", "grey", b_case1.state);
b_case2: Button(b_case2Pressed);
b_case2_svg: Button_svg(b_case2Pressed, "b_case2", "yellow", "grey", b_case2.state);
b_case3: Button(b_case3Pressed);
b_case3_svg: Button_svg(b_case3Pressed, "b_case3", "yellow", "grey", b_case3.state);
automaton UseCase:
    location Case1:
        initial;
        edge b_case1Pressed;
        edge b_case2Pressed goto Case2;
        edge b_case3Pressed goto Case3;
    location Case2:
        edge b_case1Pressed goto Case1;
        edge b_case2Pressed;
        edge b_case3Pressed goto Case3;
    location Case3:
        edge b_case1Pressed goto Case1;
        edge b_case2Pressed goto Case2;
        edge b_case3Pressed;
end

group AutoControl:
    //alg bool isActive = false;

	automaton Lift:
		alg LiftState state;
		event rejProduct;
		location Waiting:
			initial;
			equation state = STOP;
			edge when s_reflective goto WaitingForArm;
		location WaitingForArm:
		    equation state = STOP;
		    edge when not s_reflective goto VerifyBlock1;
		location VerifyBlock1:
		    equation state = STOP;
		    edge PusherContr.extent when s_capacitive and RejectBufferContr.count < 5 goto PushingBlockAtBot;
		    edge when not s_capacitive goto GoingUp;
		location PushingBlockAtBot:
		    equation state = STOP;
		    edge PusherContr.retract goto ProductFullyRedjected;
		location ProductFullyRedjected:
		    equation state = STOP;
		    edge rejProduct goto Waiting;
		location GoingUp:
			equation state = UP;
			edge when s_elevator_up goto VerifyBlock2;
		location VerifyBlock2:
		    equation state = STOP;
		    edge when s_productheight goto GoingDownReject;
		    edge PusherContr.extent when not s_productheight goto PushingBlockAtTop;
		location GoingDownReject:
		    equation state = DOWN;
		    edge PusherContr.extent when s_elevator_down and RejectBufferContr.count < 5 goto PushingBlockAtBot;
		location PushingBlockAtTop:
			equation state = STOP;
			edge PusherContr.retract goto GoingDownEmpty;
		location GoingDownEmpty:
			equation state = DOWN;
			edge when s_elevator_down goto Waiting;
	end

	automaton RejectBufferContr:
	    disc int count;
	   	location Waiting:
	   	   initial;
	   	   edge AutoControl.Lift.rejProduct do count := count + 1;
	   	   edge when s_Tresetbutton do count := 0 goto AwaitRelease;
	   	location AwaitRelease:
	   	   edge when not s_Tresetbutton do count := 0 goto Waiting;
	end

	automaton PusherContr:
		event extent, retract;
		location Extending:
			edge retract when s_pusher goto Retracting;
			edge when CountFive.Five goto Lockdown;
		location Retracting:
			initial;
			edge extent goto Extending;
			edge when CountFive.Five goto Lockdown;
		location Lockdown:								//Pusher will not push when the buffer is full
			edge when CountFive.Four goto Retracting;
	end
end

	automaton SeparatorContr:
		location Empty: //Left
			initial;
			edge when AtSepSensor.isActive goto Incoming;
		location Incoming: //Left
			edge when not AtSepSensor.isActive goto FullNoInc;

		location FullNoInc: //Left
			edge when ProcessingBusySensor.Off goto Open; 		//to be replaced by s_processingbusy
			edge when AtSepSensor.isActive goto FullInc;
		location Open: //Right
			edge when ExitSensor.isActive goto Empty;

		location FullInc: //Left + Stop conveyer
			edge when ProcessingBusySensor.Off goto OpenInc;
		location OpenInc: //Right
			edge when not AtSepSensor.isActive goto FullNoInc;

	end


	automaton ConveyerContr:
		cont t der 1;
		location Empty: 	//To save energy, it is useful to not have the conveyer active when there are no products on it.
			initial;
			edge when CountFive.OneActiveEntry goto Moving;
		location Moving:
			edge when CountFive.Zero goto Empty;
			edge when SeparatorContr.FullInc goto NotMoving;
			edge when EntrySensor.isActive goto Buffering;
		location Buffering:
			edge when not EntrySensor.isActive do t := 0 goto Delay;
		location Delay:
			edge when t > 0.5 goto NotMoving;
		location NotMoving:
			edge when EntrySensor.isActive and not SeparatorContr.FullInc goto Moving;
			edge when SeparatorContr.Open goto Moving;
			edge when SeparatorContr.OpenInc goto Moving;
	end



