// Controller to test hardware mapping, for all sensors and actuators.
//import "testing_buffering_station_plant.cif";
import "B_ctrl_BFT.cif";

input bool s_reflective;
input bool s_capacitive;
input bool s_elevator_up;
input bool s_productheight;
input bool s_elevator_down;
input bool s_Tresetbutton;
input bool s_pusher;
input bool s_Tinitialized;
input bool s_Binitialized;
input bool s_Tstartbutton;
input bool s_Bstartbutton;
input bool s_Tstopbutton;
input bool s_Tautoswitch;
input bool s_optical;
alg bool a_elevator_up = Lift2.state = UP;
alg bool a_elevator_down = Lift2.state = DOWN;
alg bool a_testingready = Lift2.Waiting;
alg bool a_pusher = PusherContr.Extending;
alg bool a_airslide = Airslide.Active;
alg bool a_TledQ1 = RejectBufferContr.count >=5;

alg bool systemReady = s_Tinitialized and s_Binitialized;

enum LiftState = UP, STOP, DOWN;

automaton SystemState:
    location Waiting:
        initial;
        edge when systemReady and s_Tstartbutton goto WaitForRelease;
    location WaitForRelease:
        edge when not s_Tstartbutton goto Running;
    location Running:
        edge when not s_Tstopbutton goto WaitForRelease2;
    location WaitForRelease2:
        edge when s_Tstopbutton goto Waiting;
end

automaton BStart:
    event void toggle;
    location Off:
        initial;
        edge when s_Bstartbutton goto On;
    location On:
        edge toggle! when not s_Bstartbutton goto Off;
end

automaton Lift2:
    alg LiftState state;
    event rejProduct;
    cont timer der 1;
    location Initializing:
        equation state = STOP;
        initial;
        edge when SystemState.Running goto Waiting;
    location Waiting:
        equation state = STOP;
        edge when s_capacitive do timer := 0 goto WaitingForArm;
    location WaitingForArm:
        equation state = STOP;
        edge BStart.toggle? when not s_Tautoswitch and not s_reflective goto VerifyBlock1;
        edge when s_Tautoswitch and not s_reflective and timer > 2 goto VerifyBlock1;
    location VerifyBlock1:
        equation state = STOP;
        edge PusherContr.extent when not s_optical and RejectBufferContr.count < 5 goto PushingBlockAtBot;
        edge when s_optical goto GoingUp;
    location PushingBlockAtBot:
        equation state = STOP;
        edge PusherContr.retract goto ProductFullyRedjected;
    location ProductFullyRedjected:
        equation state = STOP;
        edge rejProduct goto Initializing;
    location GoingUp:
        equation state = UP;
        edge BStart.toggle? when not s_Tautoswitch and s_elevator_up do timer:= 0 goto Delay2;
        edge when s_Tautoswitch and s_elevator_up do timer:= 0 goto Delay2;
    location Delay2:
        equation state = STOP;
        edge when timer > 1 goto VerifyBlock2;
    location VerifyBlock2:
        equation state = STOP;
        edge when not s_productheight goto GoingDownReject;
        edge PusherContr.extent when s_productheight goto PushingBlockAtTop;
    location GoingDownReject:
        equation state = DOWN;
        edge PusherContr.extent when s_elevator_down and RejectBufferContr.count < 5 goto PushingBlockAtBot;
    location PushingBlockAtTop:
        equation state = STOP;
        edge PusherContr.retract goto GoingDownEmpty;
    location GoingDownEmpty:
        equation state = DOWN;
        edge when s_elevator_down goto Initializing;
end

automaton RejectBufferContr:
    disc int count;
    location Waiting:
        initial;
        edge Lift2.rejProduct do count := count + 1;
        edge when s_Tresetbutton goto AwaitRelease;
    location AwaitRelease:
        edge when not s_Tresetbutton do count := 0 goto Waiting;
end

automaton PusherContr:
    event extent, retract;
    location Extending:
    edge retract when s_pusher goto Retracting;
    edge when s_bufferingbusy goto Lockdown;
    location Retracting:
        initial;
        edge extent goto Extending;
        edge when s_bufferingbusy goto Lockdown;
    location Lockdown:                              //Pusher will not push when the buffer is full
        edge when not s_bufferingbusy goto Retracting;
end

automaton Airslide:
    monitor PusherContr.extent;

    cont t der 1;
    location Active:
        edge when t > 5 goto InActive;
    location InActive:
        initial;
        edge PusherContr.extent when s_elevator_up  do t := 0 goto Active;
end

