/** Authors of this document:
 *  L.J. Buijs       0959903
 *  M.P. Favier      0951737
 *  M.W. Timmermans  0956838
 */

import "T_ctrl_BFT.cif";

// Variables used for estimating the time the product takes to complete certain actions
const real TimeOnAirslide = 0.2;
const real TimeDiffEnterAndSep  = 3;
const real TimeDiffSepAndExit = 1;
const real TimeTillAtSep = 2;

// Actuators
alg bool a_conveyer = ConveyerContr.On and not malfunction and SystemState.Running;
alg bool a_separator = SeparatorContr.AwaitProduct or SeparatorContr.ProductInSep;
alg bool a_BledQ1 = malfunction;
alg bool a_BledQ2 = actualBusy;
alg bool s_bufferingbusy = CountFive.count >= 5 or malfunction or entryListener.AwaitSensor or entryListener.AwaitEvent;

// Sensors
input bool s_product;
input bool s_atseparator;
input bool s_atexit;
input bool s_processingbusy;
input bool s_Bautoswitch;
input bool s_Bresetbutton;
alg bool actualBusy = s_processingbusy or s_Bautoswitch;

// True if there is a malfunction
alg bool malfunction = entryListener.Malfunction or separatorListener.Malfunction or exitListener.Malfunction;

// Channel for communicating when the controller thinks a product is at the entry, separator or exit
event void atEntry, atSep, atExit;
// Channel for communicating the time difference between model and actual product
event real atEntryConf, atSepConf, atExitConf;

// Maximum mismatch time between the model of the box and the sensors
const real confTime = 5;

// Variables for the products
m_box1: BoxModel();
m_box2: BoxModel();
m_box3: BoxModel();
m_box4: BoxModel();
m_box5: BoxModel();

// Used for checking for a mismatch between model and reality
errorChecker1: ErrorChecker(m_box1);
errorChecker2: ErrorChecker(m_box2);
errorChecker3: ErrorChecker(m_box3);
errorChecker4: ErrorChecker(m_box4);
errorChecker5: ErrorChecker(m_box5);

// Variables for linking model and reality
entryListener: SensorListener(atEntry, atEntryConf, s_product);
separatorListener: SensorListener(atSep, atSepConf, s_atseparator);
exitListener: SensorListener(atExit, atExitConf, s_atexit);

// Some useful type definitions
type Point = tuple(real x, y);
type Rectangle = tuple(real x, y, width, height);

// Location of the separator
const Rectangle AtSepSensorBounds = (717,260,10,41);

// Responsible for controlling the separator
automaton SeparatorContr:
    cont t der 1;
    event void close;
	location AwaitProduct:
        initial;
        edge when s_atseparator do t:= 0 goto ProductInSep;
    location ProductInSep:
        edge BStart.toggle? when not s_Tautoswitch and t > TimeTillAtSep and not actualBusy goto TurnOnConv;
        edge when s_Tautoswitch and t > TimeTillAtSep and not actualBusy goto TurnOnConv;
    location TurnOnConv:
        edge ConveyerContr.turnOn! goto Opening;
    location Opening:
        edge when s_atexit goto AwaitLeave;
        edge close? goto Delay;
    location AwaitLeave:
        edge when not s_atexit do t:= 0 goto Delay;
        edge close? do t:= 0 goto Delay;
    location Delay:
        edge when t > 1 goto TurnOffConv;
    location TurnOffConv:
        edge ConveyerContr.turnOff! goto AwaitProduct;
end

// Responsible for turning the conveyer on and off
automaton ConveyerContr:
    event void turnOn; // Request a turn on
    event void turnOff; // Request a turn off
    disc int onReqs = 0; // If onReqs > 0, then apparently someone still wants the conveyer on
    cont timer der 1;
	location Off:
		initial;
		edge turnOn ? do timer := 0, onReqs := onReqs + 1 goto On;
		edge turnOff ? do timer := 0, onReqs := onReqs - 1 goto On;
		edge when onReqs > 0 goto On;
	location On:
		edge turnOn ? do timer:=0, onReqs := onReqs + 1 goto On;
        edge turnOff ? do timer :=0, onReqs := onReqs - 1 goto On;
        edge when timer > 15 do onReqs := onReqs - 1;
        edge when onReqs <= 0 goto Off;
        edge when not SystemState.Running goto AwaitRunning;
    location AwaitRunning:
        edge when SystemState.Running do timer := 0 goto On;
end

// Responsible for turning on the conveyer when a new product enters the buffering station
automaton EntryController:
    cont timer der 1;
    location Init:
        initial;
        edge atEntryConf goto TurnOnConv;
    location TurnOnConv:
        edge ConveyerContr.turnOn! do timer := 0 goto AwaitProdAtSep;
    location AwaitProdAtSep:
        edge when timer > 5 goto TurnOffConv;
        edge when not SystemState.Running goto AwaitSystemRunning;
        edge atSepConf do timer := 0 goto Delay;
    location AwaitSystemRunning:
        edge when SystemState.Running do timer := 0 goto AwaitProdAtSep;
    location Delay:
        edge when timer > TimeTillAtSep goto TurnOffConv;
    location TurnOffConv:
        edge ConveyerContr.turnOff! goto Init;
end

//Keeps track of how many products are on the belt.
automaton CountFive:
    event void decrease;
    disc int count = 0;
    location Initial:
        initial;
        edge when s_product do count:= count+1 goto WaitFor1;
        edge when s_atexit do count:= count-1  goto WaitFor2;
        edge decrease? do count := count - 1;
    location WaitFor1:
        edge when not s_product goto Initial;
    location WaitFor2:
        edge when not s_atexit goto Initial;
end

// Responsible for listening when a new box is ejected by the testing station
automaton BoxListener:
    event void newBox;
    location Init:
        initial;
        edge newBox! when a_pusher and s_elevator_up goto Timeout;
    location Timeout:
        edge when not a_pusher goto Init;
end

// Used for comparing the sensor data and the models of the boxes
automaton def SensorListener(event void atActivation; event real atActivConf; alg bool sensor):
    cont t der 1;
    cont timeDiff der 1;
    location Init:
        initial;
        edge atActivation? do t := 0 goto AwaitSensor;
        edge when sensor do t := 0, timeDiff := 0 goto AwaitEvent;
    location AwaitSensor:
        edge atActivConf!0 when sensor goto AwaitSRelease;
        edge when t > confTime goto Malfunction;
    location AwaitEvent:
        edge atActivation? goto BroadcastConf;
        edge when t > confTime goto Malfunction;
    location BroadcastConf:
        edge atActivConf!timeDiff goto AwaitSRelease;
    location AwaitSRelease:
        edge when not sensor goto Init;
    location Malfunction:
        edge when s_Bresetbutton goto AwaitSRelease;
end

// Model of the box as simulated by the controller
automaton def BoxModel():
    monitor ProductCounter2.prodLeave, ProdBroadcast2.prodDoUpdate;
    cont x = -200;
    cont y;
    cont confTimer der 1;
    cont accelTimer der 1;
    alg real slideAngle = (10)*3.141592654/180;
    const real boxSpeed = 60;
    const real beltSpeed1 = 250 / TimeDiffEnterAndSep;
    const real beltSpeed2 = 50 / TimeDiffSepAndExit;
    const Point LiftTop = (1182.9, 228);
    disc int bufferPos;
    alg real acccelSpeed = 228 / TimeOnAirslide;
    cont rotation der rotDer;
    disc real rotDer;
    disc bool pastSep, pastEntry;
    alg Rectangle bounds = (x,y,40,23);
    event delete;
    location Waiting:
        equation x' = -boxSpeed, y' = 0;
        initial;
        edge BoxListener.newBox? do (pastSep, pastEntry) := (false,false), (x,y) := LiftTop, accelTimer := 0, rotDer := -200 goto LiftAirTransit;
    location LiftAirTransit:
        equation x' = -acccelSpeed*cos(slideAngle), y' = acccelSpeed*sin(slideAngle);
        edge when rotation < -10 do rotDer := 0, accelTimer := 0 goto OnAirslide;
   location OnAirslide:
        equation x' = -acccelSpeed*cos(slideAngle), y' = acccelSpeed*sin(slideAngle);
        edge when y > 273 do rotDer := 200 goto SlideBufferTransit;
    location SlideBufferTransit:
        equation x' = if a_conveyer: -beltSpeed1 else 0 end, y' = 0;
        edge ProductCounter2.prodEnter! when rotation > 0 do rotDer := 0, bufferPos := ProductCounter2.rightMostProdX goto OnBufferMoving;
    location OnBufferMoving:                                            //Buffer before sep
        equation x' = if a_conveyer: -beltSpeed1 else 0 end, y' = 0;
        edge when x < bufferPos - (if a_separator: 22 else 0 end) goto OnBufferWaiting;
        edge ProductCounter2.prodLeave when x > ProdBroadcast2.lastXRemoved do  bufferPos := max(bufferPos - 40, 681);
        edge atSep! when not pastSep and x < 728 do pastSep := true, confTimer := 0 goto AwaitConfSep;
        edge atEntry! when not pastEntry and x < 929 do pastEntry := true, confTimer :=0 goto AwaitConfEntry;
        edge delete goto DoDelete;
    location DoDelete:
        equation x' = 0, y' = 0;
        edge ProdBroadcast2.prodLeave!x do x := -200 goto DecreaseCount;
    location AwaitConfSep:
        equation x' = 0, y' = 0;
        edge atSepConf? do x := x - boxSpeed*? goto OnBufferMoving;
        edge ProductCounter2.prodLeave when x > ProdBroadcast2.lastXRemoved do  bufferPos := max(bufferPos - 40, 681);
        edge ProdBroadcast2.prodLeave!x when confTimer > confTime do x := -200 goto DecreaseCount;
    location AwaitConfEntry:
        equation x' = 0, y' = 0;
        edge atEntryConf? do x := x - boxSpeed*? goto OnBufferMoving;
        edge ProductCounter2.prodLeave when x > ProdBroadcast2.lastXRemoved do  bufferPos := max(bufferPos - 40, 681);
        edge ProdBroadcast2.prodLeave!x when confTimer > confTime do x := -200 goto Waiting;
    location DecreaseCount:
        equation x' = 0, y' = 0;
        edge CountFive.decrease! goto Waiting;
    location OnBufferWaiting:
        equation x' = 0, y' = 0;
        edge ProductCounter2.prodLeave when bufferPos > 682 and x > ProdBroadcast2.lastXRemoved  do bufferPos := bufferPos - 40 goto OnBufferMoving;
        edge ProdBroadcast2.prodUpdate! when a_separator and bufferPos < 682 goto ToSeperatorTransit;
        edge ProdBroadcast2.prodDoUpdate goto OnBufferMoving;
        edge delete goto DoDelete;
    location ToSeperatorTransit:
        equation x' = if a_conveyer: -beltSpeed1 else 0 end, y' = 0;
        edge when x < 660 goto InSeperatorWaiting;
    location InSeperatorWaiting:
        equation x' = 0, y' = 0;
        edge ProdBroadcast2.prodLeave!x when not a_separator goto Leaving;
    location Leaving:
        equation x' = if a_conveyer: -beltSpeed2 else 0 end, y' = 0;
        edge atExit! when x < 642 do confTimer := 0 goto AwaitConfExit;
    location AwaitConfExit:
        equation x' = 0, y' = 0;
        edge atExitConf? do x:= -200 goto Waiting;
        edge SeparatorContr.close! when confTimer > confTime do x:= -200 goto DecreaseCount;
end

// Tells every product that they should check their current product
automaton ProdBroadcast2:
    event real prodLeave;
    event void prodUpdate;
    event prodDoUpdate;
    disc real lastXRemoved;
    location Await:
        initial;
        edge prodLeave? do lastXRemoved := ? goto Send1;
        edge prodUpdate? goto Send2;
    location Send1:
        edge ProductCounter2.prodLeave! goto Await;
    location Send2:
        edge prodDoUpdate goto Await;
end

// Keeps track of where the next product should go on the buffer
automaton ProductCounter2:
    disc int rightMostProdX = 681;
    event void prodEnter, prodLeave;
    location:
        initial;
        edge prodEnter? do rightMostProdX := rightMostProdX + 40;
        edge prodLeave? do rightMostProdX := max(rightMostProdX - 40, 681);
end


// Function for checking collision between rectangles
func bool RectRectColl2(Rectangle rect; Rectangle other):
    if (rect[x] < other[x] + other[width] and
        rect[x] + rect[width] > other[x] and
        rect[y] < other[y] + other[height] and
        rect[height] + rect[y] > other[y]):
            return true;
    end
    return false;
end

// Checks for a mismatch between the model of the box (simulated by controller) and the sensors
automaton def ErrorChecker(BoxModel target):
    const real mismatchTime = 3;
    cont mismatchTimer der 1;
    alg bool modelCol = RectRectColl2(AtSepSensorBounds, target.bounds);
    alg bool mismatch = (modelCol and not s_atseparator);
    location Init:
        initial;
        edge when target.OnBufferMoving goto OnBufferMoving;
    location OnBufferMoving:
        edge when mismatch do mismatchTimer := 0 goto Await;
    location Await:
        edge when not mismatch goto OnBufferMoving;
        edge target.delete when mismatchTimer > mismatchTime goto Init;
end
