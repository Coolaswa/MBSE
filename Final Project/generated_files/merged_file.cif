const real box_opacity = 0.3;
const string box_color = "blue";
const real TimeOnAirslide = 0.2;
const real TimeDiffEnterAndSep = 3.0;
const real TimeDiffSepAndExit = 1.0;
const real TimeTillAtSep = 2.0;
alg bool a_conveyer = ConveyerContr.On and not malfunction;
alg bool a_separator = SeparatorContr.AwaitProduct or SeparatorContr.ProductInSep;
alg bool s_product = boxIAtEntry != -1;
alg bool s_atseparator = boxIAtSep != -1;
alg bool s_atexit = boxIAtExit != -1;
alg bool s_processingbusy = ProcessingBusySensor.On or s_Bautoswitch;
alg bool s_Bautoswitch = b_BautoManualSwitch.Pressed;
alg bool s_Bresetbutton = b_reset_B.Pressed;
alg bool actualBusy = s_processingbusy or s_Bautoswitch;
alg bool malfunction = entryListener.Malfunction or separatorListener.Malfunction or exitListener.Malfunction;
alg bool s_bufferingbusy = CountFive.count >= 5 or malfunction or entryListener.AwaitSensor or entryListener.AwaitEvent;
alg bool a_BledQ1 = malfunction;
alg bool a_BledQ2 = false;
event void atEntry;
event void atSep;
event void atExit;
event real atEntryConf;
event real atSepConf;
event real atExitConf;
const real confTime = 5.0;
type Point = tuple(real x; real y);
const Point LiftTop = (1182.9, 228.0);
type Rectangle = tuple(real x; real y; real width; real height);
const Rectangle AtSepSensorBounds = (717.0, 260.0, 10.0, 41.0);
func bool RectRectColl2(Rectangle rect; Rectangle other):
  if rect[x] < other[x] + other[width] and rect[x] + rect[width] > other[x] and rect[y] < other[y] + other[height] and rect[height] + rect[y] > other[y]:
    return true;
  end
  return false;
end
alg bool s_reflective = ReflexiveSensor.isActive;
alg bool s_capacitive = CapacitiveSensor.isActive;
alg bool s_elevator_up = Lift.y <= -Const.Lift.MaxHeight and not b_s_lift_up.Pressed;
alg bool s_productheight = HeightSensor.isActive;
alg bool s_elevator_down = Lift.y >= 0 and not b_s_lift_down.Pressed;
alg bool s_Tresetbutton = b_reset.Pressed;
alg bool s_pusher = Pusher.Extending and Pusher.x < -35 and not b_s_pusher.Pressed;
alg bool s_Tinitialized = true;
alg bool s_Binitialized = true;
alg bool s_Tstartbutton = b_start.state;
alg bool s_Bstartbutton = b_start_B.Pressed;
alg bool s_Tstopbutton = b_stop.state;
alg bool s_Tautoswitch = b_autoManualSwitch.Pressed;
alg bool s_optical = OpticalSensor.isActive;
alg bool a_elevator_up = Lift2.state = UP;
alg bool a_elevator_down = Lift2.state = DOWN;
alg bool a_testingready = Lift2.Waiting;
alg bool a_pusher = PusherContr.Extending or PusherContr.Malfunction;
alg bool a_airslide = Airslide.Active;
alg bool a_TledQ1 = RejectBufferContr.count >= 5;
alg bool a_TledQ2 = Lift2.malfunction or PusherContr.Malfunction;
alg bool systemReady = s_Tinitialized and s_Binitialized;
enum LiftState = UP, STOP, DOWN;
event box1Clicked;
event box2Clicked;
event box3Clicked;
event box4Clicked;
event box5Clicked;
event box6Clicked;
event box7Clicked;
event box8Clicked;
event box9Clicked;
event box10Clicked;
const real boxSpeed = 80.0;
event BoxData spawn_new_block;
event productRejected;
event void pusher_activated;
alg int boxIAtSep = RectRectColl(Const.Sensors.AtSepSensorBounds, BoxUpdater.data);
alg int boxIAtExit = RectRectColl(Const.Sensors.ExitSensorBounds, BoxUpdater.data);
alg int boxIAtEntry = RectRectColl(Const.Sensors.EntrySensorBounds, BoxUpdater.data);
type BoxData = tuple(Rectangle bounds; string color; bool thick; real rotation);
func int RectRectColl(Rectangle rect; list[10] BoxData boxes):
  int i = 0;
  int length = size(boxes);
  real height;
  real y;
  while i < length:
    height := boxes[i][bounds][height] * if boxes[i][thick]: 1.2 else 1.0 end;
    y := boxes[i][bounds][y] - 0.2 * boxes[i][bounds][height] * if boxes[i][thick]: 1.0 else 0.0 end;
    if rect[x] < boxes[i][bounds][x] + boxes[i][bounds][width] and rect[x] + rect[width] > boxes[i][bounds][x] and rect[y] < y + height and rect[height] + rect[y] > y:
      return i;
    end
    i := i + 1;
  end
  return -1;
end
group box1_svg2:
  alg string name = "Product_" + <string>idfier;
  alg string myState = if m_box1.OnBufferMoving: "moving" elif m_box1.DoDelete: "delete" elif m_box1.AwaitConfSep: "sepconf" elif m_box1.DecreaseCount: "deccount" elif m_box1.OnBufferWaiting: "wait" elif m_box1.ToSeperatorTransit: "tosep" elif m_box1.InSeperatorWaiting: "insep" else "idk" end;
  alg int idfier = 11;
  alg string color = box_color;
  alg real x = m_box1.x;
  alg real y = m_box1.y;
  alg real rot = m_box1.rotation;
  alg real opacity = box_opacity;
  svgcopy id "Product" post "_" + <string>idfier file "../SystemSVG.svg";
  svgout id name attr "transform" value fmt("translate(%f, %f) rotate(%f)", x, y, rot) file "../SystemSVG.svg";
  svgout id name attr "opacity" value opacity file "../SystemSVG.svg";
  svgout id "ProductGraphics_" + <string>idfier attr "fill" value color file "../SystemSVG.svg";
end
group box2_svg2:
  alg string name = "Product_" + <string>idfier;
  alg string myState = if m_box2.OnBufferMoving: "moving" elif m_box2.DoDelete: "delete" elif m_box2.AwaitConfSep: "sepconf" elif m_box2.DecreaseCount: "deccount" elif m_box2.OnBufferWaiting: "wait" elif m_box2.ToSeperatorTransit: "tosep" elif m_box2.InSeperatorWaiting: "insep" else "idk" end;
  alg int idfier = 12;
  alg string color = box_color;
  alg real x = m_box2.x;
  alg real y = m_box2.y;
  alg real rot = m_box2.rotation;
  alg real opacity = box_opacity;
  svgcopy id "Product" post "_" + <string>idfier file "../SystemSVG.svg";
  svgout id name attr "transform" value fmt("translate(%f, %f) rotate(%f)", x, y, rot) file "../SystemSVG.svg";
  svgout id name attr "opacity" value opacity file "../SystemSVG.svg";
  svgout id "ProductGraphics_" + <string>idfier attr "fill" value color file "../SystemSVG.svg";
end
group box3_svg2:
  alg string name = "Product_" + <string>idfier;
  alg string myState = if m_box3.OnBufferMoving: "moving" elif m_box3.DoDelete: "delete" elif m_box3.AwaitConfSep: "sepconf" elif m_box3.DecreaseCount: "deccount" elif m_box3.OnBufferWaiting: "wait" elif m_box3.ToSeperatorTransit: "tosep" elif m_box3.InSeperatorWaiting: "insep" else "idk" end;
  alg int idfier = 13;
  alg string color = box_color;
  alg real x = m_box3.x;
  alg real y = m_box3.y;
  alg real rot = m_box3.rotation;
  alg real opacity = box_opacity;
  svgcopy id "Product" post "_" + <string>idfier file "../SystemSVG.svg";
  svgout id name attr "transform" value fmt("translate(%f, %f) rotate(%f)", x, y, rot) file "../SystemSVG.svg";
  svgout id name attr "opacity" value opacity file "../SystemSVG.svg";
  svgout id "ProductGraphics_" + <string>idfier attr "fill" value color file "../SystemSVG.svg";
end
group box4_svg2:
  alg string name = "Product_" + <string>idfier;
  alg string myState = if m_box4.OnBufferMoving: "moving" elif m_box4.DoDelete: "delete" elif m_box4.AwaitConfSep: "sepconf" elif m_box4.DecreaseCount: "deccount" elif m_box4.OnBufferWaiting: "wait" elif m_box4.ToSeperatorTransit: "tosep" elif m_box4.InSeperatorWaiting: "insep" else "idk" end;
  alg int idfier = 14;
  alg string color = box_color;
  alg real x = m_box4.x;
  alg real y = m_box4.y;
  alg real rot = m_box4.rotation;
  alg real opacity = box_opacity;
  svgcopy id "Product" post "_" + <string>idfier file "../SystemSVG.svg";
  svgout id name attr "transform" value fmt("translate(%f, %f) rotate(%f)", x, y, rot) file "../SystemSVG.svg";
  svgout id name attr "opacity" value opacity file "../SystemSVG.svg";
  svgout id "ProductGraphics_" + <string>idfier attr "fill" value color file "../SystemSVG.svg";
end
group box5_svg2:
  alg string name = "Product_" + <string>idfier;
  alg string myState = if m_box5.OnBufferMoving: "moving" elif m_box5.DoDelete: "delete" elif m_box5.AwaitConfSep: "sepconf" elif m_box5.DecreaseCount: "deccount" elif m_box5.OnBufferWaiting: "wait" elif m_box5.ToSeperatorTransit: "tosep" elif m_box5.InSeperatorWaiting: "insep" else "idk" end;
  alg int idfier = 15;
  alg string color = box_color;
  alg real x = m_box5.x;
  alg real y = m_box5.y;
  alg real rot = m_box5.rotation;
  alg real opacity = box_opacity;
  svgcopy id "Product" post "_" + <string>idfier file "../SystemSVG.svg";
  svgout id name attr "transform" value fmt("translate(%f, %f) rotate(%f)", x, y, rot) file "../SystemSVG.svg";
  svgout id name attr "opacity" value opacity file "../SystemSVG.svg";
  svgout id "ProductGraphics_" + <string>idfier attr "fill" value color file "../SystemSVG.svg";
end
automaton m_box1:
  monitor ProductCounter2.prodLeave, ProdBroadcast2.prodDoUpdate;
  cont x = -200.0;
  cont y;
  cont confTimer der 1.0;
  cont accelTimer der 1.0;
  alg real slideAngle = 10 * 3.141592654 / 180;
  const real boxSpeed = 60.0;
  const real beltSpeed1 = 250 / TimeDiffEnterAndSep;
  const real beltSpeed2 = 50 / TimeDiffSepAndExit;
  disc int bufferPos;
  alg real acccelSpeed = 228 / TimeOnAirslide;
  cont rotation der rotDer;
  disc real rotDer;
  disc bool pastSep;
  disc bool pastEntry;
  alg Rectangle bounds = (x, y, 40.0, 23.0);
  event delete;
  location Waiting:
    initial;
    equation x' = -boxSpeed,
             y' = 0.0;
    edge BoxListener.newBox? do (pastSep, pastEntry) := (false, false), (x, y) := LiftTop, accelTimer := 0.0, rotDer := -200.0 goto LiftAirTransit;
  location LiftAirTransit:
    equation x' = -acccelSpeed * cos(slideAngle),
             y' = acccelSpeed * sin(slideAngle);
    edge when rotation < -10 do rotDer := 0.0, accelTimer := 0.0 goto OnAirslide;
  location OnAirslide:
    equation x' = -acccelSpeed * cos(slideAngle),
             y' = acccelSpeed * sin(slideAngle);
    edge when y > 273 do rotDer := 200.0 goto SlideBufferTransit;
  location SlideBufferTransit:
    equation x' = if a_conveyer: -beltSpeed1 else 0.0 end,
             y' = 0.0;
    edge ProductCounter2.prodEnter! when rotation > 0 do rotDer := 0.0, bufferPos := ProductCounter2.rightMostProdX goto OnBufferMoving;
  location OnBufferMoving:
    equation x' = if a_conveyer: -beltSpeed1 else 0.0 end,
             y' = 0.0;
    edge when x < bufferPos - if a_separator: 22 else 0 end goto OnBufferWaiting;
    edge ProductCounter2.prodLeave when x > ProdBroadcast2.lastXRemoved do bufferPos := max(bufferPos - 40, 681);
    edge atSep! when not pastSep and x < 728 do pastSep := true, confTimer := 0.0 goto AwaitConfSep;
    edge atEntry! when not pastEntry and x < 929 do pastEntry := true, confTimer := 0.0 goto AwaitConfEntry;
    edge delete goto DoDelete;
  location DoDelete:
    equation x' = 0.0,
             y' = 0.0;
    edge ProdBroadcast2.prodLeave!x do x := -200.0 goto DecreaseCount;
  location AwaitConfSep:
    equation x' = 0.0,
             y' = 0.0;
    edge atSepConf? do x := x - boxSpeed * ? goto OnBufferMoving;
    edge ProductCounter2.prodLeave when x > ProdBroadcast2.lastXRemoved do bufferPos := max(bufferPos - 40, 681);
    edge ProdBroadcast2.prodLeave!x when confTimer > confTime do x := -200.0 goto DecreaseCount;
  location AwaitConfEntry:
    equation x' = 0.0,
             y' = 0.0;
    edge atEntryConf? do x := x - boxSpeed * ? goto OnBufferMoving;
    edge ProductCounter2.prodLeave when x > ProdBroadcast2.lastXRemoved do bufferPos := max(bufferPos - 40, 681);
    edge ProdBroadcast2.prodLeave!x when confTimer > confTime do x := -200.0 goto Waiting;
  location DecreaseCount:
    equation x' = 0.0,
             y' = 0.0;
    edge CountFive.decrease! goto Waiting;
  location OnBufferWaiting:
    equation x' = 0.0,
             y' = 0.0;
    edge ProductCounter2.prodLeave when bufferPos > 682 and x > ProdBroadcast2.lastXRemoved do bufferPos := bufferPos - 40 goto OnBufferMoving;
    edge ProdBroadcast2.prodUpdate! when a_separator and bufferPos < 682 goto ToSeperatorTransit;
    edge ProdBroadcast2.prodDoUpdate goto OnBufferMoving;
    edge delete goto DoDelete;
  location ToSeperatorTransit:
    equation x' = if a_conveyer: -beltSpeed1 else 0.0 end,
             y' = 0.0;
    edge when x < 660 goto InSeperatorWaiting;
  location InSeperatorWaiting:
    equation x' = 0.0,
             y' = 0.0;
    edge ProdBroadcast2.prodLeave!x when not a_separator goto Leaving;
  location Leaving:
    equation x' = -beltSpeed2,
             y' = 0.0;
    edge atExit! when x < 642 do confTimer := 0.0 goto AwaitConfExit;
  location AwaitConfExit:
    equation x' = 0.0,
             y' = 0.0;
    edge atExitConf? do x := -200.0 goto Waiting;
    edge SeparatorContr.close! when confTimer > confTime do x := -200.0 goto DecreaseCount;
end
automaton m_box2:
  monitor ProductCounter2.prodLeave, ProdBroadcast2.prodDoUpdate;
  cont x = -200.0;
  cont y;
  cont confTimer der 1.0;
  cont accelTimer der 1.0;
  alg real slideAngle = 10 * 3.141592654 / 180;
  const real boxSpeed = 60.0;
  const real beltSpeed1 = 250 / TimeDiffEnterAndSep;
  const real beltSpeed2 = 50 / TimeDiffSepAndExit;
  disc int bufferPos;
  alg real acccelSpeed = 228 / TimeOnAirslide;
  cont rotation der rotDer;
  disc real rotDer;
  disc bool pastSep;
  disc bool pastEntry;
  alg Rectangle bounds = (x, y, 40.0, 23.0);
  event delete;
  location Waiting:
    initial;
    equation x' = -boxSpeed,
             y' = 0.0;
    edge BoxListener.newBox? do (pastSep, pastEntry) := (false, false), (x, y) := LiftTop, accelTimer := 0.0, rotDer := -200.0 goto LiftAirTransit;
  location LiftAirTransit:
    equation x' = -acccelSpeed * cos(slideAngle),
             y' = acccelSpeed * sin(slideAngle);
    edge when rotation < -10 do rotDer := 0.0, accelTimer := 0.0 goto OnAirslide;
  location OnAirslide:
    equation x' = -acccelSpeed * cos(slideAngle),
             y' = acccelSpeed * sin(slideAngle);
    edge when y > 273 do rotDer := 200.0 goto SlideBufferTransit;
  location SlideBufferTransit:
    equation x' = if a_conveyer: -beltSpeed1 else 0.0 end,
             y' = 0.0;
    edge ProductCounter2.prodEnter! when rotation > 0 do rotDer := 0.0, bufferPos := ProductCounter2.rightMostProdX goto OnBufferMoving;
  location OnBufferMoving:
    equation x' = if a_conveyer: -beltSpeed1 else 0.0 end,
             y' = 0.0;
    edge when x < bufferPos - if a_separator: 22 else 0 end goto OnBufferWaiting;
    edge ProductCounter2.prodLeave when x > ProdBroadcast2.lastXRemoved do bufferPos := max(bufferPos - 40, 681);
    edge atSep! when not pastSep and x < 728 do pastSep := true, confTimer := 0.0 goto AwaitConfSep;
    edge atEntry! when not pastEntry and x < 929 do pastEntry := true, confTimer := 0.0 goto AwaitConfEntry;
    edge delete goto DoDelete;
  location DoDelete:
    equation x' = 0.0,
             y' = 0.0;
    edge ProdBroadcast2.prodLeave!x do x := -200.0 goto DecreaseCount;
  location AwaitConfSep:
    equation x' = 0.0,
             y' = 0.0;
    edge atSepConf? do x := x - boxSpeed * ? goto OnBufferMoving;
    edge ProductCounter2.prodLeave when x > ProdBroadcast2.lastXRemoved do bufferPos := max(bufferPos - 40, 681);
    edge ProdBroadcast2.prodLeave!x when confTimer > confTime do x := -200.0 goto DecreaseCount;
  location AwaitConfEntry:
    equation x' = 0.0,
             y' = 0.0;
    edge atEntryConf? do x := x - boxSpeed * ? goto OnBufferMoving;
    edge ProductCounter2.prodLeave when x > ProdBroadcast2.lastXRemoved do bufferPos := max(bufferPos - 40, 681);
    edge ProdBroadcast2.prodLeave!x when confTimer > confTime do x := -200.0 goto Waiting;
  location DecreaseCount:
    equation x' = 0.0,
             y' = 0.0;
    edge CountFive.decrease! goto Waiting;
  location OnBufferWaiting:
    equation x' = 0.0,
             y' = 0.0;
    edge ProductCounter2.prodLeave when bufferPos > 682 and x > ProdBroadcast2.lastXRemoved do bufferPos := bufferPos - 40 goto OnBufferMoving;
    edge ProdBroadcast2.prodUpdate! when a_separator and bufferPos < 682 goto ToSeperatorTransit;
    edge ProdBroadcast2.prodDoUpdate goto OnBufferMoving;
    edge delete goto DoDelete;
  location ToSeperatorTransit:
    equation x' = if a_conveyer: -beltSpeed1 else 0.0 end,
             y' = 0.0;
    edge when x < 660 goto InSeperatorWaiting;
  location InSeperatorWaiting:
    equation x' = 0.0,
             y' = 0.0;
    edge ProdBroadcast2.prodLeave!x when not a_separator goto Leaving;
  location Leaving:
    equation x' = -beltSpeed2,
             y' = 0.0;
    edge atExit! when x < 642 do confTimer := 0.0 goto AwaitConfExit;
  location AwaitConfExit:
    equation x' = 0.0,
             y' = 0.0;
    edge atExitConf? do x := -200.0 goto Waiting;
    edge SeparatorContr.close! when confTimer > confTime do x := -200.0 goto DecreaseCount;
end
automaton m_box3:
  monitor ProductCounter2.prodLeave, ProdBroadcast2.prodDoUpdate;
  cont x = -200.0;
  cont y;
  cont confTimer der 1.0;
  cont accelTimer der 1.0;
  alg real slideAngle = 10 * 3.141592654 / 180;
  const real boxSpeed = 60.0;
  const real beltSpeed1 = 250 / TimeDiffEnterAndSep;
  const real beltSpeed2 = 50 / TimeDiffSepAndExit;
  disc int bufferPos;
  alg real acccelSpeed = 228 / TimeOnAirslide;
  cont rotation der rotDer;
  disc real rotDer;
  disc bool pastSep;
  disc bool pastEntry;
  alg Rectangle bounds = (x, y, 40.0, 23.0);
  event delete;
  location Waiting:
    initial;
    equation x' = -boxSpeed,
             y' = 0.0;
    edge BoxListener.newBox? do (pastSep, pastEntry) := (false, false), (x, y) := LiftTop, accelTimer := 0.0, rotDer := -200.0 goto LiftAirTransit;
  location LiftAirTransit:
    equation x' = -acccelSpeed * cos(slideAngle),
             y' = acccelSpeed * sin(slideAngle);
    edge when rotation < -10 do rotDer := 0.0, accelTimer := 0.0 goto OnAirslide;
  location OnAirslide:
    equation x' = -acccelSpeed * cos(slideAngle),
             y' = acccelSpeed * sin(slideAngle);
    edge when y > 273 do rotDer := 200.0 goto SlideBufferTransit;
  location SlideBufferTransit:
    equation x' = if a_conveyer: -beltSpeed1 else 0.0 end,
             y' = 0.0;
    edge ProductCounter2.prodEnter! when rotation > 0 do rotDer := 0.0, bufferPos := ProductCounter2.rightMostProdX goto OnBufferMoving;
  location OnBufferMoving:
    equation x' = if a_conveyer: -beltSpeed1 else 0.0 end,
             y' = 0.0;
    edge when x < bufferPos - if a_separator: 22 else 0 end goto OnBufferWaiting;
    edge ProductCounter2.prodLeave when x > ProdBroadcast2.lastXRemoved do bufferPos := max(bufferPos - 40, 681);
    edge atSep! when not pastSep and x < 728 do pastSep := true, confTimer := 0.0 goto AwaitConfSep;
    edge atEntry! when not pastEntry and x < 929 do pastEntry := true, confTimer := 0.0 goto AwaitConfEntry;
    edge delete goto DoDelete;
  location DoDelete:
    equation x' = 0.0,
             y' = 0.0;
    edge ProdBroadcast2.prodLeave!x do x := -200.0 goto DecreaseCount;
  location AwaitConfSep:
    equation x' = 0.0,
             y' = 0.0;
    edge atSepConf? do x := x - boxSpeed * ? goto OnBufferMoving;
    edge ProductCounter2.prodLeave when x > ProdBroadcast2.lastXRemoved do bufferPos := max(bufferPos - 40, 681);
    edge ProdBroadcast2.prodLeave!x when confTimer > confTime do x := -200.0 goto DecreaseCount;
  location AwaitConfEntry:
    equation x' = 0.0,
             y' = 0.0;
    edge atEntryConf? do x := x - boxSpeed * ? goto OnBufferMoving;
    edge ProductCounter2.prodLeave when x > ProdBroadcast2.lastXRemoved do bufferPos := max(bufferPos - 40, 681);
    edge ProdBroadcast2.prodLeave!x when confTimer > confTime do x := -200.0 goto Waiting;
  location DecreaseCount:
    equation x' = 0.0,
             y' = 0.0;
    edge CountFive.decrease! goto Waiting;
  location OnBufferWaiting:
    equation x' = 0.0,
             y' = 0.0;
    edge ProductCounter2.prodLeave when bufferPos > 682 and x > ProdBroadcast2.lastXRemoved do bufferPos := bufferPos - 40 goto OnBufferMoving;
    edge ProdBroadcast2.prodUpdate! when a_separator and bufferPos < 682 goto ToSeperatorTransit;
    edge ProdBroadcast2.prodDoUpdate goto OnBufferMoving;
    edge delete goto DoDelete;
  location ToSeperatorTransit:
    equation x' = if a_conveyer: -beltSpeed1 else 0.0 end,
             y' = 0.0;
    edge when x < 660 goto InSeperatorWaiting;
  location InSeperatorWaiting:
    equation x' = 0.0,
             y' = 0.0;
    edge ProdBroadcast2.prodLeave!x when not a_separator goto Leaving;
  location Leaving:
    equation x' = -beltSpeed2,
             y' = 0.0;
    edge atExit! when x < 642 do confTimer := 0.0 goto AwaitConfExit;
  location AwaitConfExit:
    equation x' = 0.0,
             y' = 0.0;
    edge atExitConf? do x := -200.0 goto Waiting;
    edge SeparatorContr.close! when confTimer > confTime do x := -200.0 goto DecreaseCount;
end
automaton m_box4:
  monitor ProductCounter2.prodLeave, ProdBroadcast2.prodDoUpdate;
  cont x = -200.0;
  cont y;
  cont confTimer der 1.0;
  cont accelTimer der 1.0;
  alg real slideAngle = 10 * 3.141592654 / 180;
  const real boxSpeed = 60.0;
  const real beltSpeed1 = 250 / TimeDiffEnterAndSep;
  const real beltSpeed2 = 50 / TimeDiffSepAndExit;
  disc int bufferPos;
  alg real acccelSpeed = 228 / TimeOnAirslide;
  cont rotation der rotDer;
  disc real rotDer;
  disc bool pastSep;
  disc bool pastEntry;
  alg Rectangle bounds = (x, y, 40.0, 23.0);
  event delete;
  location Waiting:
    initial;
    equation x' = -boxSpeed,
             y' = 0.0;
    edge BoxListener.newBox? do (pastSep, pastEntry) := (false, false), (x, y) := LiftTop, accelTimer := 0.0, rotDer := -200.0 goto LiftAirTransit;
  location LiftAirTransit:
    equation x' = -acccelSpeed * cos(slideAngle),
             y' = acccelSpeed * sin(slideAngle);
    edge when rotation < -10 do rotDer := 0.0, accelTimer := 0.0 goto OnAirslide;
  location OnAirslide:
    equation x' = -acccelSpeed * cos(slideAngle),
             y' = acccelSpeed * sin(slideAngle);
    edge when y > 273 do rotDer := 200.0 goto SlideBufferTransit;
  location SlideBufferTransit:
    equation x' = if a_conveyer: -beltSpeed1 else 0.0 end,
             y' = 0.0;
    edge ProductCounter2.prodEnter! when rotation > 0 do rotDer := 0.0, bufferPos := ProductCounter2.rightMostProdX goto OnBufferMoving;
  location OnBufferMoving:
    equation x' = if a_conveyer: -beltSpeed1 else 0.0 end,
             y' = 0.0;
    edge when x < bufferPos - if a_separator: 22 else 0 end goto OnBufferWaiting;
    edge ProductCounter2.prodLeave when x > ProdBroadcast2.lastXRemoved do bufferPos := max(bufferPos - 40, 681);
    edge atSep! when not pastSep and x < 728 do pastSep := true, confTimer := 0.0 goto AwaitConfSep;
    edge atEntry! when not pastEntry and x < 929 do pastEntry := true, confTimer := 0.0 goto AwaitConfEntry;
    edge delete goto DoDelete;
  location DoDelete:
    equation x' = 0.0,
             y' = 0.0;
    edge ProdBroadcast2.prodLeave!x do x := -200.0 goto DecreaseCount;
  location AwaitConfSep:
    equation x' = 0.0,
             y' = 0.0;
    edge atSepConf? do x := x - boxSpeed * ? goto OnBufferMoving;
    edge ProductCounter2.prodLeave when x > ProdBroadcast2.lastXRemoved do bufferPos := max(bufferPos - 40, 681);
    edge ProdBroadcast2.prodLeave!x when confTimer > confTime do x := -200.0 goto DecreaseCount;
  location AwaitConfEntry:
    equation x' = 0.0,
             y' = 0.0;
    edge atEntryConf? do x := x - boxSpeed * ? goto OnBufferMoving;
    edge ProductCounter2.prodLeave when x > ProdBroadcast2.lastXRemoved do bufferPos := max(bufferPos - 40, 681);
    edge ProdBroadcast2.prodLeave!x when confTimer > confTime do x := -200.0 goto Waiting;
  location DecreaseCount:
    equation x' = 0.0,
             y' = 0.0;
    edge CountFive.decrease! goto Waiting;
  location OnBufferWaiting:
    equation x' = 0.0,
             y' = 0.0;
    edge ProductCounter2.prodLeave when bufferPos > 682 and x > ProdBroadcast2.lastXRemoved do bufferPos := bufferPos - 40 goto OnBufferMoving;
    edge ProdBroadcast2.prodUpdate! when a_separator and bufferPos < 682 goto ToSeperatorTransit;
    edge ProdBroadcast2.prodDoUpdate goto OnBufferMoving;
    edge delete goto DoDelete;
  location ToSeperatorTransit:
    equation x' = if a_conveyer: -beltSpeed1 else 0.0 end,
             y' = 0.0;
    edge when x < 660 goto InSeperatorWaiting;
  location InSeperatorWaiting:
    equation x' = 0.0,
             y' = 0.0;
    edge ProdBroadcast2.prodLeave!x when not a_separator goto Leaving;
  location Leaving:
    equation x' = -beltSpeed2,
             y' = 0.0;
    edge atExit! when x < 642 do confTimer := 0.0 goto AwaitConfExit;
  location AwaitConfExit:
    equation x' = 0.0,
             y' = 0.0;
    edge atExitConf? do x := -200.0 goto Waiting;
    edge SeparatorContr.close! when confTimer > confTime do x := -200.0 goto DecreaseCount;
end
automaton m_box5:
  monitor ProductCounter2.prodLeave, ProdBroadcast2.prodDoUpdate;
  cont x = -200.0;
  cont y;
  cont confTimer der 1.0;
  cont accelTimer der 1.0;
  alg real slideAngle = 10 * 3.141592654 / 180;
  const real boxSpeed = 60.0;
  const real beltSpeed1 = 250 / TimeDiffEnterAndSep;
  const real beltSpeed2 = 50 / TimeDiffSepAndExit;
  disc int bufferPos;
  alg real acccelSpeed = 228 / TimeOnAirslide;
  cont rotation der rotDer;
  disc real rotDer;
  disc bool pastSep;
  disc bool pastEntry;
  alg Rectangle bounds = (x, y, 40.0, 23.0);
  event delete;
  location Waiting:
    initial;
    equation x' = -boxSpeed,
             y' = 0.0;
    edge BoxListener.newBox? do (pastSep, pastEntry) := (false, false), (x, y) := LiftTop, accelTimer := 0.0, rotDer := -200.0 goto LiftAirTransit;
  location LiftAirTransit:
    equation x' = -acccelSpeed * cos(slideAngle),
             y' = acccelSpeed * sin(slideAngle);
    edge when rotation < -10 do rotDer := 0.0, accelTimer := 0.0 goto OnAirslide;
  location OnAirslide:
    equation x' = -acccelSpeed * cos(slideAngle),
             y' = acccelSpeed * sin(slideAngle);
    edge when y > 273 do rotDer := 200.0 goto SlideBufferTransit;
  location SlideBufferTransit:
    equation x' = if a_conveyer: -beltSpeed1 else 0.0 end,
             y' = 0.0;
    edge ProductCounter2.prodEnter! when rotation > 0 do rotDer := 0.0, bufferPos := ProductCounter2.rightMostProdX goto OnBufferMoving;
  location OnBufferMoving:
    equation x' = if a_conveyer: -beltSpeed1 else 0.0 end,
             y' = 0.0;
    edge when x < bufferPos - if a_separator: 22 else 0 end goto OnBufferWaiting;
    edge ProductCounter2.prodLeave when x > ProdBroadcast2.lastXRemoved do bufferPos := max(bufferPos - 40, 681);
    edge atSep! when not pastSep and x < 728 do pastSep := true, confTimer := 0.0 goto AwaitConfSep;
    edge atEntry! when not pastEntry and x < 929 do pastEntry := true, confTimer := 0.0 goto AwaitConfEntry;
    edge delete goto DoDelete;
  location DoDelete:
    equation x' = 0.0,
             y' = 0.0;
    edge ProdBroadcast2.prodLeave!x do x := -200.0 goto DecreaseCount;
  location AwaitConfSep:
    equation x' = 0.0,
             y' = 0.0;
    edge atSepConf? do x := x - boxSpeed * ? goto OnBufferMoving;
    edge ProductCounter2.prodLeave when x > ProdBroadcast2.lastXRemoved do bufferPos := max(bufferPos - 40, 681);
    edge ProdBroadcast2.prodLeave!x when confTimer > confTime do x := -200.0 goto DecreaseCount;
  location AwaitConfEntry:
    equation x' = 0.0,
             y' = 0.0;
    edge atEntryConf? do x := x - boxSpeed * ? goto OnBufferMoving;
    edge ProductCounter2.prodLeave when x > ProdBroadcast2.lastXRemoved do bufferPos := max(bufferPos - 40, 681);
    edge ProdBroadcast2.prodLeave!x when confTimer > confTime do x := -200.0 goto Waiting;
  location DecreaseCount:
    equation x' = 0.0,
             y' = 0.0;
    edge CountFive.decrease! goto Waiting;
  location OnBufferWaiting:
    equation x' = 0.0,
             y' = 0.0;
    edge ProductCounter2.prodLeave when bufferPos > 682 and x > ProdBroadcast2.lastXRemoved do bufferPos := bufferPos - 40 goto OnBufferMoving;
    edge ProdBroadcast2.prodUpdate! when a_separator and bufferPos < 682 goto ToSeperatorTransit;
    edge ProdBroadcast2.prodDoUpdate goto OnBufferMoving;
    edge delete goto DoDelete;
  location ToSeperatorTransit:
    equation x' = if a_conveyer: -beltSpeed1 else 0.0 end,
             y' = 0.0;
    edge when x < 660 goto InSeperatorWaiting;
  location InSeperatorWaiting:
    equation x' = 0.0,
             y' = 0.0;
    edge ProdBroadcast2.prodLeave!x when not a_separator goto Leaving;
  location Leaving:
    equation x' = -beltSpeed2,
             y' = 0.0;
    edge atExit! when x < 642 do confTimer := 0.0 goto AwaitConfExit;
  location AwaitConfExit:
    equation x' = 0.0,
             y' = 0.0;
    edge atExitConf? do x := -200.0 goto Waiting;
    edge SeparatorContr.close! when confTimer > confTime do x := -200.0 goto DecreaseCount;
end
automaton errorChecker1:
  const real mismatchTime = 3.0;
  cont mismatchTimer der 1.0;
  alg bool modelCol = RectRectColl2(AtSepSensorBounds, m_box1.bounds);
  alg bool mismatch = modelCol and not s_atseparator;
  location Init:
    initial;
    edge when m_box1.OnBufferMoving goto OnBufferMoving;
  location OnBufferMoving:
    edge when mismatch do mismatchTimer := 0.0 goto Await;
  location Await:
    edge when not mismatch goto OnBufferMoving;
    edge m_box1.delete when mismatchTimer > mismatchTime goto Init;
end
automaton errorChecker2:
  const real mismatchTime = 3.0;
  cont mismatchTimer der 1.0;
  alg bool modelCol = RectRectColl2(AtSepSensorBounds, m_box2.bounds);
  alg bool mismatch = modelCol and not s_atseparator;
  location Init:
    initial;
    edge when m_box2.OnBufferMoving goto OnBufferMoving;
  location OnBufferMoving:
    edge when mismatch do mismatchTimer := 0.0 goto Await;
  location Await:
    edge when not mismatch goto OnBufferMoving;
    edge m_box2.delete when mismatchTimer > mismatchTime goto Init;
end
automaton errorChecker3:
  const real mismatchTime = 3.0;
  cont mismatchTimer der 1.0;
  alg bool modelCol = RectRectColl2(AtSepSensorBounds, m_box3.bounds);
  alg bool mismatch = modelCol and not s_atseparator;
  location Init:
    initial;
    edge when m_box3.OnBufferMoving goto OnBufferMoving;
  location OnBufferMoving:
    edge when mismatch do mismatchTimer := 0.0 goto Await;
  location Await:
    edge when not mismatch goto OnBufferMoving;
    edge m_box3.delete when mismatchTimer > mismatchTime goto Init;
end
automaton errorChecker4:
  const real mismatchTime = 3.0;
  cont mismatchTimer der 1.0;
  alg bool modelCol = RectRectColl2(AtSepSensorBounds, m_box4.bounds);
  alg bool mismatch = modelCol and not s_atseparator;
  location Init:
    initial;
    edge when m_box4.OnBufferMoving goto OnBufferMoving;
  location OnBufferMoving:
    edge when mismatch do mismatchTimer := 0.0 goto Await;
  location Await:
    edge when not mismatch goto OnBufferMoving;
    edge m_box4.delete when mismatchTimer > mismatchTime goto Init;
end
automaton errorChecker5:
  const real mismatchTime = 3.0;
  cont mismatchTimer der 1.0;
  alg bool modelCol = RectRectColl2(AtSepSensorBounds, m_box5.bounds);
  alg bool mismatch = modelCol and not s_atseparator;
  location Init:
    initial;
    edge when m_box5.OnBufferMoving goto OnBufferMoving;
  location OnBufferMoving:
    edge when mismatch do mismatchTimer := 0.0 goto Await;
  location Await:
    edge when not mismatch goto OnBufferMoving;
    edge m_box5.delete when mismatchTimer > mismatchTime goto Init;
end
automaton entryListener:
  cont t der 1.0;
  cont timeDiff der 1.0;
  alg bool sensor = s_product;
  location Init:
    initial;
    edge atEntry? do t := 0.0 goto AwaitSensor;
    edge when sensor do t := 0.0, timeDiff := 0.0 goto AwaitEvent;
  location AwaitSensor:
    edge atEntryConf!0.0 when sensor goto AwaitSRelease;
    edge when t > confTime goto Malfunction;
  location AwaitEvent:
    edge atEntry? goto BroadcastConf;
    edge when t > confTime goto Malfunction;
  location BroadcastConf:
    edge atEntryConf!timeDiff goto AwaitSRelease;
  location AwaitSRelease:
    edge when not sensor goto Init;
  location Malfunction:
    edge when s_Bresetbutton goto AwaitSRelease;
end
automaton separatorListener:
  cont t der 1.0;
  cont timeDiff der 1.0;
  alg bool sensor = s_atseparator;
  location Init:
    initial;
    edge atSep? do t := 0.0 goto AwaitSensor;
    edge when sensor do t := 0.0, timeDiff := 0.0 goto AwaitEvent;
  location AwaitSensor:
    edge atSepConf!0.0 when sensor goto AwaitSRelease;
    edge when t > confTime goto Malfunction;
  location AwaitEvent:
    edge atSep? goto BroadcastConf;
    edge when t > confTime goto Malfunction;
  location BroadcastConf:
    edge atSepConf!timeDiff goto AwaitSRelease;
  location AwaitSRelease:
    edge when not sensor goto Init;
  location Malfunction:
    edge when s_Bresetbutton goto AwaitSRelease;
end
automaton exitListener:
  cont t der 1.0;
  cont timeDiff der 1.0;
  alg bool sensor = s_atexit;
  location Init:
    initial;
    edge atExit? do t := 0.0 goto AwaitSensor;
    edge when sensor do t := 0.0, timeDiff := 0.0 goto AwaitEvent;
  location AwaitSensor:
    edge atExitConf!0.0 when sensor goto AwaitSRelease;
    edge when t > confTime goto Malfunction;
  location AwaitEvent:
    edge atExit? goto BroadcastConf;
    edge when t > confTime goto Malfunction;
  location BroadcastConf:
    edge atExitConf!timeDiff goto AwaitSRelease;
  location AwaitSRelease:
    edge when not sensor goto Init;
  location Malfunction:
    edge when s_Bresetbutton goto AwaitSRelease;
end
automaton SeparatorContr:
  cont t der 1.0;
  event void close;
  location AwaitProduct:
    initial;
    edge when s_atseparator do t := 0.0 goto ProductInSep;
  location ProductInSep:
    edge BStart.toggle? when not s_Tautoswitch and t > TimeTillAtSep and not actualBusy goto TurnOnConv;
    edge when s_Tautoswitch and t > TimeTillAtSep and not actualBusy goto TurnOnConv;
  location TurnOnConv:
    edge ConveyerContr.turnOn! goto Opening;
  location Opening:
    edge when s_atexit goto AwaitLeave;
    edge close? goto AwaitProduct;
  location AwaitLeave:
    edge when not s_atexit goto TurnOffConv;
    edge close? goto TurnOffConv;
  location TurnOffConv:
    edge ConveyerContr.turnOff! goto AwaitProduct;
end
automaton ConveyerContr:
  event void turnOn;
  event void turnOff;
  disc int onReqs = 0;
  location Off:
    initial;
    edge turnOn? do onReqs := onReqs + 1 goto On;
    edge turnOff? do onReqs := onReqs - 1 goto On;
    edge when onReqs > 0 goto On;
  location On:
    edge turnOn? do onReqs := onReqs + 1 goto On;
    edge turnOff? do onReqs := onReqs - 1 goto On;
    edge when onReqs <= 0 goto Off;
end
automaton EntryController:
  cont timer der 1.0;
  location Init:
    initial;
    edge atEntryConf goto TurnOnConv;
  location TurnOnConv:
    edge ConveyerContr.turnOn! do timer := 0.0 goto AwaitProdAtSep;
  location AwaitProdAtSep:
    edge when timer > 5 goto TurnOffConv;
    edge atSepConf do timer := 0.0 goto Delay;
  location Delay:
    edge when timer > TimeTillAtSep goto TurnOffConv;
  location TurnOffConv:
    edge ConveyerContr.turnOff! goto Init;
end
automaton CountFive:
  event void decrease;
  disc int count = 0;
  location Initial:
    initial;
    edge when s_product do count := count + 1 goto WaitFor1;
    edge when s_atexit do count := count - 1 goto WaitFor2;
    edge decrease? do count := count - 1;
  location WaitFor1:
    edge when not s_product goto Initial;
  location WaitFor2:
    edge when not s_atexit goto Initial;
end
automaton BoxListener:
  event void newBox;
  location Init:
    initial;
    edge newBox! when a_pusher and s_elevator_up goto Timeout;
  location Timeout:
    edge when not a_pusher goto Init;
end
automaton ProdBroadcast2:
  event real prodLeave;
  event void prodUpdate;
  event prodDoUpdate;
  disc real lastXRemoved;
  location Await:
    initial;
    edge prodLeave? do lastXRemoved := ? goto Send1;
    edge prodUpdate? goto Send2;
  location Send1:
    edge ProductCounter2.prodLeave! goto Await;
  location Send2:
    edge prodDoUpdate goto Await;
end
automaton ProductCounter2:
  disc int rightMostProdX = 681;
  event void prodEnter;
  event void prodLeave;
  location:
    initial;
    edge prodEnter? do rightMostProdX := rightMostProdX + 40;
    edge prodLeave? do rightMostProdX := max(rightMostProdX - 40, 681);
end
automaton SystemState:
  location Waiting:
    initial;
    edge when systemReady and s_Tstartbutton goto WaitForRelease;
  location WaitForRelease:
    edge when not s_Tstartbutton goto Running;
  location Running:
    edge when not s_Tstopbutton goto WaitForRelease2;
  location WaitForRelease2:
    edge when s_Tstopbutton goto Waiting;
end
automaton BStart:
  event void toggle;
  location Off:
    initial;
    edge when s_Bstartbutton goto On;
  location On:
    edge toggle! when not s_Bstartbutton goto Off;
end
automaton Lift2:
  alg LiftState state;
  event rejProduct;
  cont timer der 1.0;
  const int[5..5] travelTime = 5;
  disc bool malfunction;
  location Initializing:
    initial;
    equation state = STOP;
    edge when SystemState.Running do timer := 0.0 goto PreWaiting;
  location PreWaiting:
    equation state = STOP;
    edge when timer > 1 do timer := 0.0 goto Waiting;
  location Waiting:
    equation state = STOP;
    edge when s_capacitive do timer := 0.0 goto WaitingForArm;
  location WaitingForArm:
    equation state = STOP;
    edge BStart.toggle? when not s_Tautoswitch and not s_reflective goto VerifyBlock1;
    edge when s_Tautoswitch and not s_reflective and timer > 2 goto VerifyBlock1;
  location VerifyBlock1:
    equation state = STOP;
    edge PusherContr.extent when not s_optical and RejectBufferContr.count < 5 goto PushingBlockAtBot;
    edge when s_optical do timer := 0.0 goto GoingUp;
  location PushingBlockAtBot:
    equation state = STOP;
    edge PusherContr.retract goto ProductFullyRedjected;
  location ProductFullyRedjected:
    equation state = STOP;
    edge rejProduct goto Initializing;
  location GoingUp:
    equation state = UP;
    edge BStart.toggle? when not s_Tautoswitch and s_elevator_up do timer := 0.0 goto Delay2;
    edge when s_Tautoswitch and s_elevator_up do timer := 0.0 goto Delay2;
    edge when timer > travelTime do malfunction := true goto UpMalfunct;
  location UpMalfunct:
    equation state = STOP;
    edge when s_Tstartbutton do malfunction := false, timer := 0.0 goto GoingUp;
  location Delay2:
    equation state = STOP;
    edge when timer > 1 goto VerifyBlock2;
  location VerifyBlock2:
    equation state = STOP;
    edge when not s_productheight do timer := 0.0 goto GoingDownReject;
    edge PusherContr.extent when s_productheight and not s_bufferingbusy goto PushingBlockAtTop;
  location GoingDownReject:
    equation state = DOWN;
    edge PusherContr.extent when s_elevator_down and RejectBufferContr.count < 5 goto PushingBlockAtBot;
    edge when timer > travelTime do malfunction := true goto DownRejectMalf;
  location DownRejectMalf:
    equation state = STOP;
    edge when s_Tstartbutton do malfunction := false, timer := 0.0 goto GoingDownReject;
  location PushingBlockAtTop:
    equation state = STOP;
    edge PusherContr.retract do timer := 0.0 goto GoingDownEmpty;
  location GoingDownEmpty:
    equation state = DOWN;
    edge when s_elevator_down goto Initializing;
    edge when timer > travelTime do malfunction := true goto DownEmptyMalf;
  location DownEmptyMalf:
    equation state = STOP;
    edge when s_Tstartbutton do malfunction := false, timer := 0.0 goto GoingDownEmpty;
end
automaton RejectBufferContr:
  disc int count;
  location Waiting:
    initial;
    edge Lift2.rejProduct do count := count + 1;
    edge when s_Tresetbutton goto AwaitRelease;
  location AwaitRelease:
    edge when not s_Tresetbutton do count := 0 goto Waiting;
end
automaton PusherContr:
  event extent;
  event retract;
  cont timer der 1.0;
  location Extending:
    edge retract when s_pusher goto Retracting;
    edge when timer > 5 goto Malfunction;
  location Retracting:
    initial;
    edge extent do timer := 0.0 goto Extending;
  location Malfunction:
    edge when s_Tstartbutton do timer := 0.0 goto Extending;
end
automaton Airslide:
  monitor PusherContr.extent;
  cont t der 1.0;
  location Active:
    edge when t > 2 goto InActive;
  location InActive:
    initial;
    edge PusherContr.extent when s_elevator_up do t := 0.0 goto Active;
end
automaton box1:
  monitor productRejected, ProductCounter.prodLeave, ProdBroadcast.prodDoUpdate, box1Clicked;
  event void clicked;
  cont x = -200.0;
  cont y = -200.0;
  disc string color = "pink";
  disc bool isThick = false;
  cont rotation = 0.0 der rotDer;
  disc real rotDer = 0.0;
  cont accelTimer = 1.0 der 1.0;
  alg real acccelSpeed = min(accelTimer * 2000.0, 800000.0) + boxSpeed;
  const real timeOnAirslide = 0.2;
  alg real slideAngle = 10 * 3.141592654 / 180;
  disc int productRejectPosX = 1138;
  disc int bufferPos;
  const int[1178..1178] productRejectStartX = 1178;
  const int[1138..1138] productConstRejectX = 1138;
  alg real boxSpeedInArm = 2 * 3.1415 * 181 / 360 * Arm.armSpeed;
  location Inactive:
    initial;
    equation x' = 0.0,
             y' = 0.0;
    edge spawn_new_block? do (x, y, color, isThick) := (?[bounds][x], ?[bounds][y], ?[color], ?[thick]), productRejectPosX := productConstRejectX, rotation := 0.0 goto InArm;
  location InArm:
    equation x' = -boxSpeedInArm * cos(Arm.armRot / 180 * 3.1415),
             y' = -boxSpeedInArm * sin(Arm.armRot / 180 * 3.1415);
    edge when isThick and y > Const.Box.LiftPos[y] + 23.0 * 0.2 do (x, y) := Const.Box.LiftPos goto InLift;
    edge when not isThick and y > Const.Box.LiftPos[y] do (x, y) := Const.Box.LiftPos goto InLift;
  location InLift:
    equation x' = 0.0,
             y' = Lift.speed;
    edge pusher_activated? when s_elevator_up do rotDer := -30.0 goto LiftSlideTransit;
    edge pusher_activated? when s_elevator_down goto PreRejectBufferTransit;
  location PreRejectBufferTransit:
    equation x' = -boxSpeed,
             y' = 0.0;
    edge RejectBuffer.preRejectEnter! when x < productRejectStartX goto RejectBufferTransit;
  location RejectBufferTransit:
    equation x' = -boxSpeed,
             y' = 0.0;
    edge when x < productRejectPosX goto OnRejectBuffer;
  location OnRejectBuffer:
    equation x' = 0.0,
             y' = 0.0;
    edge productRejected do productRejectPosX := productRejectPosX - Const.Box.Size goto RejectBufferTransit;
    edge when b_reset.Pressed goto AwaitResetRelease;
  location AwaitResetRelease:
    equation x' = 0.0,
             y' = 0.0;
    edge when b_reset.Released do (x, y) := (-200.0, -200.0) goto Inactive;
  location LiftSlideTransit:
    equation x' = -boxSpeed * cos(slideAngle),
             y' = boxSpeed * sin(slideAngle);
    edge when rotation < -10 do rotDer := 0.0, accelTimer := 0.0 goto OnAirslide;
    edge box1Clicked goto Removed;
    edge clicked? goto Removed;
  location OnAirslide:
    equation x' = -acccelSpeed * cos(slideAngle),
             y' = acccelSpeed * sin(slideAngle);
    edge when y > Const.Box.BufferY do rotDer := boxSpeed goto SlideBufferTransit;
    edge box1Clicked goto Removed;
    edge clicked? goto Removed;
  location SlideBufferTransit:
    equation x' = -boxSpeed,
             y' = 0.0;
    edge ProductCounter.prodEnter! when rotation > 0 do rotDer := 0.0, bufferPos := ProductCounter.rightMostProdX goto OnBufferMoving;
    edge box1Clicked goto Removed;
    edge clicked? goto Removed;
  location OnBufferMoving:
    equation x' = Belt.speed,
             y' = 0.0;
    edge when x < bufferPos - if a_separator: 22 else 0 end goto OnBufferWaiting;
    edge ProductCounter.prodLeave when x > ProdBroadcast.lastXRemoved do bufferPos := max(bufferPos - 40, 681);
    edge box1Clicked goto Removed;
    edge clicked? goto Removed;
  location OnBufferWaiting:
    equation x' = 0.0,
             y' = 0.0;
    edge ProductCounter.prodLeave when bufferPos > 682 and x > ProdBroadcast.lastXRemoved do bufferPos := bufferPos - 40 goto OnBufferMoving;
    edge ProdBroadcast.prodUpdate! when a_separator and bufferPos < 682 goto ToSeperatorTransit;
    edge ProdBroadcast.prodDoUpdate goto OnBufferMoving;
    edge box1Clicked goto Removed;
    edge clicked? goto Removed;
  location ToSeperatorTransit:
    equation x' = Belt.speed,
             y' = 0.0;
    edge when x < 660 goto InSeperatorWaiting;
    edge box1Clicked goto Removed;
    edge clicked? goto Removed;
  location InSeperatorWaiting:
    equation x' = 0.0,
             y' = 0.0;
    edge ProdBroadcast.prodLeave!x when not a_separator goto BufferEndTransit;
    edge box1Clicked goto Removed;
    edge clicked? goto Removed;
  location BufferEndTransit:
    equation x' = -boxSpeed,
             y' = 0.0;
    edge when x < 546 goto Inactive;
    edge box1Clicked goto Removed;
    edge clicked? goto Removed;
  location Removed:
    equation x' = 0.0,
             y' = 0.0;
    edge ProdBroadcast.prodLeave!x do x := -200.0 goto Inactive;
end
automaton box2:
  monitor productRejected, ProductCounter.prodLeave, ProdBroadcast.prodDoUpdate, box2Clicked;
  event void clicked;
  cont x = -200.0;
  cont y = -200.0;
  disc string color = "pink";
  disc bool isThick = false;
  cont rotation = 0.0 der rotDer;
  disc real rotDer = 0.0;
  cont accelTimer = 1.0 der 1.0;
  alg real acccelSpeed = min(accelTimer * 2000.0, 800000.0) + boxSpeed;
  const real timeOnAirslide = 0.2;
  alg real slideAngle = 10 * 3.141592654 / 180;
  disc int productRejectPosX = 1138;
  disc int bufferPos;
  const int[1178..1178] productRejectStartX = 1178;
  const int[1138..1138] productConstRejectX = 1138;
  alg real boxSpeedInArm = 2 * 3.1415 * 181 / 360 * Arm.armSpeed;
  location Inactive:
    initial;
    equation x' = 0.0,
             y' = 0.0;
    edge spawn_new_block? do (x, y, color, isThick) := (?[bounds][x], ?[bounds][y], ?[color], ?[thick]), productRejectPosX := productConstRejectX, rotation := 0.0 goto InArm;
  location InArm:
    equation x' = -boxSpeedInArm * cos(Arm.armRot / 180 * 3.1415),
             y' = -boxSpeedInArm * sin(Arm.armRot / 180 * 3.1415);
    edge when isThick and y > Const.Box.LiftPos[y] + 23.0 * 0.2 do (x, y) := Const.Box.LiftPos goto InLift;
    edge when not isThick and y > Const.Box.LiftPos[y] do (x, y) := Const.Box.LiftPos goto InLift;
  location InLift:
    equation x' = 0.0,
             y' = Lift.speed;
    edge pusher_activated? when s_elevator_up do rotDer := -30.0 goto LiftSlideTransit;
    edge pusher_activated? when s_elevator_down goto PreRejectBufferTransit;
  location PreRejectBufferTransit:
    equation x' = -boxSpeed,
             y' = 0.0;
    edge RejectBuffer.preRejectEnter! when x < productRejectStartX goto RejectBufferTransit;
  location RejectBufferTransit:
    equation x' = -boxSpeed,
             y' = 0.0;
    edge when x < productRejectPosX goto OnRejectBuffer;
  location OnRejectBuffer:
    equation x' = 0.0,
             y' = 0.0;
    edge productRejected do productRejectPosX := productRejectPosX - Const.Box.Size goto RejectBufferTransit;
    edge when b_reset.Pressed goto AwaitResetRelease;
  location AwaitResetRelease:
    equation x' = 0.0,
             y' = 0.0;
    edge when b_reset.Released do (x, y) := (-200.0, -200.0) goto Inactive;
  location LiftSlideTransit:
    equation x' = -boxSpeed * cos(slideAngle),
             y' = boxSpeed * sin(slideAngle);
    edge when rotation < -10 do rotDer := 0.0, accelTimer := 0.0 goto OnAirslide;
    edge box2Clicked goto Removed;
    edge clicked? goto Removed;
  location OnAirslide:
    equation x' = -acccelSpeed * cos(slideAngle),
             y' = acccelSpeed * sin(slideAngle);
    edge when y > Const.Box.BufferY do rotDer := boxSpeed goto SlideBufferTransit;
    edge box2Clicked goto Removed;
    edge clicked? goto Removed;
  location SlideBufferTransit:
    equation x' = -boxSpeed,
             y' = 0.0;
    edge ProductCounter.prodEnter! when rotation > 0 do rotDer := 0.0, bufferPos := ProductCounter.rightMostProdX goto OnBufferMoving;
    edge box2Clicked goto Removed;
    edge clicked? goto Removed;
  location OnBufferMoving:
    equation x' = Belt.speed,
             y' = 0.0;
    edge when x < bufferPos - if a_separator: 22 else 0 end goto OnBufferWaiting;
    edge ProductCounter.prodLeave when x > ProdBroadcast.lastXRemoved do bufferPos := max(bufferPos - 40, 681);
    edge box2Clicked goto Removed;
    edge clicked? goto Removed;
  location OnBufferWaiting:
    equation x' = 0.0,
             y' = 0.0;
    edge ProductCounter.prodLeave when bufferPos > 682 and x > ProdBroadcast.lastXRemoved do bufferPos := bufferPos - 40 goto OnBufferMoving;
    edge ProdBroadcast.prodUpdate! when a_separator and bufferPos < 682 goto ToSeperatorTransit;
    edge ProdBroadcast.prodDoUpdate goto OnBufferMoving;
    edge box2Clicked goto Removed;
    edge clicked? goto Removed;
  location ToSeperatorTransit:
    equation x' = Belt.speed,
             y' = 0.0;
    edge when x < 660 goto InSeperatorWaiting;
    edge box2Clicked goto Removed;
    edge clicked? goto Removed;
  location InSeperatorWaiting:
    equation x' = 0.0,
             y' = 0.0;
    edge ProdBroadcast.prodLeave!x when not a_separator goto BufferEndTransit;
    edge box2Clicked goto Removed;
    edge clicked? goto Removed;
  location BufferEndTransit:
    equation x' = -boxSpeed,
             y' = 0.0;
    edge when x < 546 goto Inactive;
    edge box2Clicked goto Removed;
    edge clicked? goto Removed;
  location Removed:
    equation x' = 0.0,
             y' = 0.0;
    edge ProdBroadcast.prodLeave!x do x := -200.0 goto Inactive;
end
automaton box3:
  monitor productRejected, ProductCounter.prodLeave, ProdBroadcast.prodDoUpdate, box3Clicked;
  event void clicked;
  cont x = -200.0;
  cont y = -200.0;
  disc string color = "pink";
  disc bool isThick = false;
  cont rotation = 0.0 der rotDer;
  disc real rotDer = 0.0;
  cont accelTimer = 1.0 der 1.0;
  alg real acccelSpeed = min(accelTimer * 2000.0, 800000.0) + boxSpeed;
  const real timeOnAirslide = 0.2;
  alg real slideAngle = 10 * 3.141592654 / 180;
  disc int productRejectPosX = 1138;
  disc int bufferPos;
  const int[1178..1178] productRejectStartX = 1178;
  const int[1138..1138] productConstRejectX = 1138;
  alg real boxSpeedInArm = 2 * 3.1415 * 181 / 360 * Arm.armSpeed;
  location Inactive:
    initial;
    equation x' = 0.0,
             y' = 0.0;
    edge spawn_new_block? do (x, y, color, isThick) := (?[bounds][x], ?[bounds][y], ?[color], ?[thick]), productRejectPosX := productConstRejectX, rotation := 0.0 goto InArm;
  location InArm:
    equation x' = -boxSpeedInArm * cos(Arm.armRot / 180 * 3.1415),
             y' = -boxSpeedInArm * sin(Arm.armRot / 180 * 3.1415);
    edge when isThick and y > Const.Box.LiftPos[y] + 23.0 * 0.2 do (x, y) := Const.Box.LiftPos goto InLift;
    edge when not isThick and y > Const.Box.LiftPos[y] do (x, y) := Const.Box.LiftPos goto InLift;
  location InLift:
    equation x' = 0.0,
             y' = Lift.speed;
    edge pusher_activated? when s_elevator_up do rotDer := -30.0 goto LiftSlideTransit;
    edge pusher_activated? when s_elevator_down goto PreRejectBufferTransit;
  location PreRejectBufferTransit:
    equation x' = -boxSpeed,
             y' = 0.0;
    edge RejectBuffer.preRejectEnter! when x < productRejectStartX goto RejectBufferTransit;
  location RejectBufferTransit:
    equation x' = -boxSpeed,
             y' = 0.0;
    edge when x < productRejectPosX goto OnRejectBuffer;
  location OnRejectBuffer:
    equation x' = 0.0,
             y' = 0.0;
    edge productRejected do productRejectPosX := productRejectPosX - Const.Box.Size goto RejectBufferTransit;
    edge when b_reset.Pressed goto AwaitResetRelease;
  location AwaitResetRelease:
    equation x' = 0.0,
             y' = 0.0;
    edge when b_reset.Released do (x, y) := (-200.0, -200.0) goto Inactive;
  location LiftSlideTransit:
    equation x' = -boxSpeed * cos(slideAngle),
             y' = boxSpeed * sin(slideAngle);
    edge when rotation < -10 do rotDer := 0.0, accelTimer := 0.0 goto OnAirslide;
    edge box3Clicked goto Removed;
    edge clicked? goto Removed;
  location OnAirslide:
    equation x' = -acccelSpeed * cos(slideAngle),
             y' = acccelSpeed * sin(slideAngle);
    edge when y > Const.Box.BufferY do rotDer := boxSpeed goto SlideBufferTransit;
    edge box3Clicked goto Removed;
    edge clicked? goto Removed;
  location SlideBufferTransit:
    equation x' = -boxSpeed,
             y' = 0.0;
    edge ProductCounter.prodEnter! when rotation > 0 do rotDer := 0.0, bufferPos := ProductCounter.rightMostProdX goto OnBufferMoving;
    edge box3Clicked goto Removed;
    edge clicked? goto Removed;
  location OnBufferMoving:
    equation x' = Belt.speed,
             y' = 0.0;
    edge when x < bufferPos - if a_separator: 22 else 0 end goto OnBufferWaiting;
    edge ProductCounter.prodLeave when x > ProdBroadcast.lastXRemoved do bufferPos := max(bufferPos - 40, 681);
    edge box3Clicked goto Removed;
    edge clicked? goto Removed;
  location OnBufferWaiting:
    equation x' = 0.0,
             y' = 0.0;
    edge ProductCounter.prodLeave when bufferPos > 682 and x > ProdBroadcast.lastXRemoved do bufferPos := bufferPos - 40 goto OnBufferMoving;
    edge ProdBroadcast.prodUpdate! when a_separator and bufferPos < 682 goto ToSeperatorTransit;
    edge ProdBroadcast.prodDoUpdate goto OnBufferMoving;
    edge box3Clicked goto Removed;
    edge clicked? goto Removed;
  location ToSeperatorTransit:
    equation x' = Belt.speed,
             y' = 0.0;
    edge when x < 660 goto InSeperatorWaiting;
    edge box3Clicked goto Removed;
    edge clicked? goto Removed;
  location InSeperatorWaiting:
    equation x' = 0.0,
             y' = 0.0;
    edge ProdBroadcast.prodLeave!x when not a_separator goto BufferEndTransit;
    edge box3Clicked goto Removed;
    edge clicked? goto Removed;
  location BufferEndTransit:
    equation x' = -boxSpeed,
             y' = 0.0;
    edge when x < 546 goto Inactive;
    edge box3Clicked goto Removed;
    edge clicked? goto Removed;
  location Removed:
    equation x' = 0.0,
             y' = 0.0;
    edge ProdBroadcast.prodLeave!x do x := -200.0 goto Inactive;
end
automaton box4:
  monitor productRejected, ProductCounter.prodLeave, ProdBroadcast.prodDoUpdate, box4Clicked;
  event void clicked;
  cont x = -200.0;
  cont y = -200.0;
  disc string color = "pink";
  disc bool isThick = false;
  cont rotation = 0.0 der rotDer;
  disc real rotDer = 0.0;
  cont accelTimer = 1.0 der 1.0;
  alg real acccelSpeed = min(accelTimer * 2000.0, 800000.0) + boxSpeed;
  const real timeOnAirslide = 0.2;
  alg real slideAngle = 10 * 3.141592654 / 180;
  disc int productRejectPosX = 1138;
  disc int bufferPos;
  const int[1178..1178] productRejectStartX = 1178;
  const int[1138..1138] productConstRejectX = 1138;
  alg real boxSpeedInArm = 2 * 3.1415 * 181 / 360 * Arm.armSpeed;
  location Inactive:
    initial;
    equation x' = 0.0,
             y' = 0.0;
    edge spawn_new_block? do (x, y, color, isThick) := (?[bounds][x], ?[bounds][y], ?[color], ?[thick]), productRejectPosX := productConstRejectX, rotation := 0.0 goto InArm;
  location InArm:
    equation x' = -boxSpeedInArm * cos(Arm.armRot / 180 * 3.1415),
             y' = -boxSpeedInArm * sin(Arm.armRot / 180 * 3.1415);
    edge when isThick and y > Const.Box.LiftPos[y] + 23.0 * 0.2 do (x, y) := Const.Box.LiftPos goto InLift;
    edge when not isThick and y > Const.Box.LiftPos[y] do (x, y) := Const.Box.LiftPos goto InLift;
  location InLift:
    equation x' = 0.0,
             y' = Lift.speed;
    edge pusher_activated? when s_elevator_up do rotDer := -30.0 goto LiftSlideTransit;
    edge pusher_activated? when s_elevator_down goto PreRejectBufferTransit;
  location PreRejectBufferTransit:
    equation x' = -boxSpeed,
             y' = 0.0;
    edge RejectBuffer.preRejectEnter! when x < productRejectStartX goto RejectBufferTransit;
  location RejectBufferTransit:
    equation x' = -boxSpeed,
             y' = 0.0;
    edge when x < productRejectPosX goto OnRejectBuffer;
  location OnRejectBuffer:
    equation x' = 0.0,
             y' = 0.0;
    edge productRejected do productRejectPosX := productRejectPosX - Const.Box.Size goto RejectBufferTransit;
    edge when b_reset.Pressed goto AwaitResetRelease;
  location AwaitResetRelease:
    equation x' = 0.0,
             y' = 0.0;
    edge when b_reset.Released do (x, y) := (-200.0, -200.0) goto Inactive;
  location LiftSlideTransit:
    equation x' = -boxSpeed * cos(slideAngle),
             y' = boxSpeed * sin(slideAngle);
    edge when rotation < -10 do rotDer := 0.0, accelTimer := 0.0 goto OnAirslide;
    edge box4Clicked goto Removed;
    edge clicked? goto Removed;
  location OnAirslide:
    equation x' = -acccelSpeed * cos(slideAngle),
             y' = acccelSpeed * sin(slideAngle);
    edge when y > Const.Box.BufferY do rotDer := boxSpeed goto SlideBufferTransit;
    edge box4Clicked goto Removed;
    edge clicked? goto Removed;
  location SlideBufferTransit:
    equation x' = -boxSpeed,
             y' = 0.0;
    edge ProductCounter.prodEnter! when rotation > 0 do rotDer := 0.0, bufferPos := ProductCounter.rightMostProdX goto OnBufferMoving;
    edge box4Clicked goto Removed;
    edge clicked? goto Removed;
  location OnBufferMoving:
    equation x' = Belt.speed,
             y' = 0.0;
    edge when x < bufferPos - if a_separator: 22 else 0 end goto OnBufferWaiting;
    edge ProductCounter.prodLeave when x > ProdBroadcast.lastXRemoved do bufferPos := max(bufferPos - 40, 681);
    edge box4Clicked goto Removed;
    edge clicked? goto Removed;
  location OnBufferWaiting:
    equation x' = 0.0,
             y' = 0.0;
    edge ProductCounter.prodLeave when bufferPos > 682 and x > ProdBroadcast.lastXRemoved do bufferPos := bufferPos - 40 goto OnBufferMoving;
    edge ProdBroadcast.prodUpdate! when a_separator and bufferPos < 682 goto ToSeperatorTransit;
    edge ProdBroadcast.prodDoUpdate goto OnBufferMoving;
    edge box4Clicked goto Removed;
    edge clicked? goto Removed;
  location ToSeperatorTransit:
    equation x' = Belt.speed,
             y' = 0.0;
    edge when x < 660 goto InSeperatorWaiting;
    edge box4Clicked goto Removed;
    edge clicked? goto Removed;
  location InSeperatorWaiting:
    equation x' = 0.0,
             y' = 0.0;
    edge ProdBroadcast.prodLeave!x when not a_separator goto BufferEndTransit;
    edge box4Clicked goto Removed;
    edge clicked? goto Removed;
  location BufferEndTransit:
    equation x' = -boxSpeed,
             y' = 0.0;
    edge when x < 546 goto Inactive;
    edge box4Clicked goto Removed;
    edge clicked? goto Removed;
  location Removed:
    equation x' = 0.0,
             y' = 0.0;
    edge ProdBroadcast.prodLeave!x do x := -200.0 goto Inactive;
end
automaton box5:
  monitor productRejected, ProductCounter.prodLeave, ProdBroadcast.prodDoUpdate, box5Clicked;
  event void clicked;
  cont x = -200.0;
  cont y = -200.0;
  disc string color = "pink";
  disc bool isThick = false;
  cont rotation = 0.0 der rotDer;
  disc real rotDer = 0.0;
  cont accelTimer = 1.0 der 1.0;
  alg real acccelSpeed = min(accelTimer * 2000.0, 800000.0) + boxSpeed;
  const real timeOnAirslide = 0.2;
  alg real slideAngle = 10 * 3.141592654 / 180;
  disc int productRejectPosX = 1138;
  disc int bufferPos;
  const int[1178..1178] productRejectStartX = 1178;
  const int[1138..1138] productConstRejectX = 1138;
  alg real boxSpeedInArm = 2 * 3.1415 * 181 / 360 * Arm.armSpeed;
  location Inactive:
    initial;
    equation x' = 0.0,
             y' = 0.0;
    edge spawn_new_block? do (x, y, color, isThick) := (?[bounds][x], ?[bounds][y], ?[color], ?[thick]), productRejectPosX := productConstRejectX, rotation := 0.0 goto InArm;
  location InArm:
    equation x' = -boxSpeedInArm * cos(Arm.armRot / 180 * 3.1415),
             y' = -boxSpeedInArm * sin(Arm.armRot / 180 * 3.1415);
    edge when isThick and y > Const.Box.LiftPos[y] + 23.0 * 0.2 do (x, y) := Const.Box.LiftPos goto InLift;
    edge when not isThick and y > Const.Box.LiftPos[y] do (x, y) := Const.Box.LiftPos goto InLift;
  location InLift:
    equation x' = 0.0,
             y' = Lift.speed;
    edge pusher_activated? when s_elevator_up do rotDer := -30.0 goto LiftSlideTransit;
    edge pusher_activated? when s_elevator_down goto PreRejectBufferTransit;
  location PreRejectBufferTransit:
    equation x' = -boxSpeed,
             y' = 0.0;
    edge RejectBuffer.preRejectEnter! when x < productRejectStartX goto RejectBufferTransit;
  location RejectBufferTransit:
    equation x' = -boxSpeed,
             y' = 0.0;
    edge when x < productRejectPosX goto OnRejectBuffer;
  location OnRejectBuffer:
    equation x' = 0.0,
             y' = 0.0;
    edge productRejected do productRejectPosX := productRejectPosX - Const.Box.Size goto RejectBufferTransit;
    edge when b_reset.Pressed goto AwaitResetRelease;
  location AwaitResetRelease:
    equation x' = 0.0,
             y' = 0.0;
    edge when b_reset.Released do (x, y) := (-200.0, -200.0) goto Inactive;
  location LiftSlideTransit:
    equation x' = -boxSpeed * cos(slideAngle),
             y' = boxSpeed * sin(slideAngle);
    edge when rotation < -10 do rotDer := 0.0, accelTimer := 0.0 goto OnAirslide;
    edge box5Clicked goto Removed;
    edge clicked? goto Removed;
  location OnAirslide:
    equation x' = -acccelSpeed * cos(slideAngle),
             y' = acccelSpeed * sin(slideAngle);
    edge when y > Const.Box.BufferY do rotDer := boxSpeed goto SlideBufferTransit;
    edge box5Clicked goto Removed;
    edge clicked? goto Removed;
  location SlideBufferTransit:
    equation x' = -boxSpeed,
             y' = 0.0;
    edge ProductCounter.prodEnter! when rotation > 0 do rotDer := 0.0, bufferPos := ProductCounter.rightMostProdX goto OnBufferMoving;
    edge box5Clicked goto Removed;
    edge clicked? goto Removed;
  location OnBufferMoving:
    equation x' = Belt.speed,
             y' = 0.0;
    edge when x < bufferPos - if a_separator: 22 else 0 end goto OnBufferWaiting;
    edge ProductCounter.prodLeave when x > ProdBroadcast.lastXRemoved do bufferPos := max(bufferPos - 40, 681);
    edge box5Clicked goto Removed;
    edge clicked? goto Removed;
  location OnBufferWaiting:
    equation x' = 0.0,
             y' = 0.0;
    edge ProductCounter.prodLeave when bufferPos > 682 and x > ProdBroadcast.lastXRemoved do bufferPos := bufferPos - 40 goto OnBufferMoving;
    edge ProdBroadcast.prodUpdate! when a_separator and bufferPos < 682 goto ToSeperatorTransit;
    edge ProdBroadcast.prodDoUpdate goto OnBufferMoving;
    edge box5Clicked goto Removed;
    edge clicked? goto Removed;
  location ToSeperatorTransit:
    equation x' = Belt.speed,
             y' = 0.0;
    edge when x < 660 goto InSeperatorWaiting;
    edge box5Clicked goto Removed;
    edge clicked? goto Removed;
  location InSeperatorWaiting:
    equation x' = 0.0,
             y' = 0.0;
    edge ProdBroadcast.prodLeave!x when not a_separator goto BufferEndTransit;
    edge box5Clicked goto Removed;
    edge clicked? goto Removed;
  location BufferEndTransit:
    equation x' = -boxSpeed,
             y' = 0.0;
    edge when x < 546 goto Inactive;
    edge box5Clicked goto Removed;
    edge clicked? goto Removed;
  location Removed:
    equation x' = 0.0,
             y' = 0.0;
    edge ProdBroadcast.prodLeave!x do x := -200.0 goto Inactive;
end
automaton box6:
  monitor productRejected, ProductCounter.prodLeave, ProdBroadcast.prodDoUpdate, box6Clicked;
  event void clicked;
  cont x = -200.0;
  cont y = -200.0;
  disc string color = "pink";
  disc bool isThick = false;
  cont rotation = 0.0 der rotDer;
  disc real rotDer = 0.0;
  cont accelTimer = 1.0 der 1.0;
  alg real acccelSpeed = min(accelTimer * 2000.0, 800000.0) + boxSpeed;
  const real timeOnAirslide = 0.2;
  alg real slideAngle = 10 * 3.141592654 / 180;
  disc int productRejectPosX = 1138;
  disc int bufferPos;
  const int[1178..1178] productRejectStartX = 1178;
  const int[1138..1138] productConstRejectX = 1138;
  alg real boxSpeedInArm = 2 * 3.1415 * 181 / 360 * Arm.armSpeed;
  location Inactive:
    initial;
    equation x' = 0.0,
             y' = 0.0;
    edge spawn_new_block? do (x, y, color, isThick) := (?[bounds][x], ?[bounds][y], ?[color], ?[thick]), productRejectPosX := productConstRejectX, rotation := 0.0 goto InArm;
  location InArm:
    equation x' = -boxSpeedInArm * cos(Arm.armRot / 180 * 3.1415),
             y' = -boxSpeedInArm * sin(Arm.armRot / 180 * 3.1415);
    edge when isThick and y > Const.Box.LiftPos[y] + 23.0 * 0.2 do (x, y) := Const.Box.LiftPos goto InLift;
    edge when not isThick and y > Const.Box.LiftPos[y] do (x, y) := Const.Box.LiftPos goto InLift;
  location InLift:
    equation x' = 0.0,
             y' = Lift.speed;
    edge pusher_activated? when s_elevator_up do rotDer := -30.0 goto LiftSlideTransit;
    edge pusher_activated? when s_elevator_down goto PreRejectBufferTransit;
  location PreRejectBufferTransit:
    equation x' = -boxSpeed,
             y' = 0.0;
    edge RejectBuffer.preRejectEnter! when x < productRejectStartX goto RejectBufferTransit;
  location RejectBufferTransit:
    equation x' = -boxSpeed,
             y' = 0.0;
    edge when x < productRejectPosX goto OnRejectBuffer;
  location OnRejectBuffer:
    equation x' = 0.0,
             y' = 0.0;
    edge productRejected do productRejectPosX := productRejectPosX - Const.Box.Size goto RejectBufferTransit;
    edge when b_reset.Pressed goto AwaitResetRelease;
  location AwaitResetRelease:
    equation x' = 0.0,
             y' = 0.0;
    edge when b_reset.Released do (x, y) := (-200.0, -200.0) goto Inactive;
  location LiftSlideTransit:
    equation x' = -boxSpeed * cos(slideAngle),
             y' = boxSpeed * sin(slideAngle);
    edge when rotation < -10 do rotDer := 0.0, accelTimer := 0.0 goto OnAirslide;
    edge box6Clicked goto Removed;
    edge clicked? goto Removed;
  location OnAirslide:
    equation x' = -acccelSpeed * cos(slideAngle),
             y' = acccelSpeed * sin(slideAngle);
    edge when y > Const.Box.BufferY do rotDer := boxSpeed goto SlideBufferTransit;
    edge box6Clicked goto Removed;
    edge clicked? goto Removed;
  location SlideBufferTransit:
    equation x' = -boxSpeed,
             y' = 0.0;
    edge ProductCounter.prodEnter! when rotation > 0 do rotDer := 0.0, bufferPos := ProductCounter.rightMostProdX goto OnBufferMoving;
    edge box6Clicked goto Removed;
    edge clicked? goto Removed;
  location OnBufferMoving:
    equation x' = Belt.speed,
             y' = 0.0;
    edge when x < bufferPos - if a_separator: 22 else 0 end goto OnBufferWaiting;
    edge ProductCounter.prodLeave when x > ProdBroadcast.lastXRemoved do bufferPos := max(bufferPos - 40, 681);
    edge box6Clicked goto Removed;
    edge clicked? goto Removed;
  location OnBufferWaiting:
    equation x' = 0.0,
             y' = 0.0;
    edge ProductCounter.prodLeave when bufferPos > 682 and x > ProdBroadcast.lastXRemoved do bufferPos := bufferPos - 40 goto OnBufferMoving;
    edge ProdBroadcast.prodUpdate! when a_separator and bufferPos < 682 goto ToSeperatorTransit;
    edge ProdBroadcast.prodDoUpdate goto OnBufferMoving;
    edge box6Clicked goto Removed;
    edge clicked? goto Removed;
  location ToSeperatorTransit:
    equation x' = Belt.speed,
             y' = 0.0;
    edge when x < 660 goto InSeperatorWaiting;
    edge box6Clicked goto Removed;
    edge clicked? goto Removed;
  location InSeperatorWaiting:
    equation x' = 0.0,
             y' = 0.0;
    edge ProdBroadcast.prodLeave!x when not a_separator goto BufferEndTransit;
    edge box6Clicked goto Removed;
    edge clicked? goto Removed;
  location BufferEndTransit:
    equation x' = -boxSpeed,
             y' = 0.0;
    edge when x < 546 goto Inactive;
    edge box6Clicked goto Removed;
    edge clicked? goto Removed;
  location Removed:
    equation x' = 0.0,
             y' = 0.0;
    edge ProdBroadcast.prodLeave!x do x := -200.0 goto Inactive;
end
automaton box7:
  monitor productRejected, ProductCounter.prodLeave, ProdBroadcast.prodDoUpdate, box7Clicked;
  event void clicked;
  cont x = -200.0;
  cont y = -200.0;
  disc string color = "pink";
  disc bool isThick = false;
  cont rotation = 0.0 der rotDer;
  disc real rotDer = 0.0;
  cont accelTimer = 1.0 der 1.0;
  alg real acccelSpeed = min(accelTimer * 2000.0, 800000.0) + boxSpeed;
  const real timeOnAirslide = 0.2;
  alg real slideAngle = 10 * 3.141592654 / 180;
  disc int productRejectPosX = 1138;
  disc int bufferPos;
  const int[1178..1178] productRejectStartX = 1178;
  const int[1138..1138] productConstRejectX = 1138;
  alg real boxSpeedInArm = 2 * 3.1415 * 181 / 360 * Arm.armSpeed;
  location Inactive:
    initial;
    equation x' = 0.0,
             y' = 0.0;
    edge spawn_new_block? do (x, y, color, isThick) := (?[bounds][x], ?[bounds][y], ?[color], ?[thick]), productRejectPosX := productConstRejectX, rotation := 0.0 goto InArm;
  location InArm:
    equation x' = -boxSpeedInArm * cos(Arm.armRot / 180 * 3.1415),
             y' = -boxSpeedInArm * sin(Arm.armRot / 180 * 3.1415);
    edge when isThick and y > Const.Box.LiftPos[y] + 23.0 * 0.2 do (x, y) := Const.Box.LiftPos goto InLift;
    edge when not isThick and y > Const.Box.LiftPos[y] do (x, y) := Const.Box.LiftPos goto InLift;
  location InLift:
    equation x' = 0.0,
             y' = Lift.speed;
    edge pusher_activated? when s_elevator_up do rotDer := -30.0 goto LiftSlideTransit;
    edge pusher_activated? when s_elevator_down goto PreRejectBufferTransit;
  location PreRejectBufferTransit:
    equation x' = -boxSpeed,
             y' = 0.0;
    edge RejectBuffer.preRejectEnter! when x < productRejectStartX goto RejectBufferTransit;
  location RejectBufferTransit:
    equation x' = -boxSpeed,
             y' = 0.0;
    edge when x < productRejectPosX goto OnRejectBuffer;
  location OnRejectBuffer:
    equation x' = 0.0,
             y' = 0.0;
    edge productRejected do productRejectPosX := productRejectPosX - Const.Box.Size goto RejectBufferTransit;
    edge when b_reset.Pressed goto AwaitResetRelease;
  location AwaitResetRelease:
    equation x' = 0.0,
             y' = 0.0;
    edge when b_reset.Released do (x, y) := (-200.0, -200.0) goto Inactive;
  location LiftSlideTransit:
    equation x' = -boxSpeed * cos(slideAngle),
             y' = boxSpeed * sin(slideAngle);
    edge when rotation < -10 do rotDer := 0.0, accelTimer := 0.0 goto OnAirslide;
    edge box7Clicked goto Removed;
    edge clicked? goto Removed;
  location OnAirslide:
    equation x' = -acccelSpeed * cos(slideAngle),
             y' = acccelSpeed * sin(slideAngle);
    edge when y > Const.Box.BufferY do rotDer := boxSpeed goto SlideBufferTransit;
    edge box7Clicked goto Removed;
    edge clicked? goto Removed;
  location SlideBufferTransit:
    equation x' = -boxSpeed,
             y' = 0.0;
    edge ProductCounter.prodEnter! when rotation > 0 do rotDer := 0.0, bufferPos := ProductCounter.rightMostProdX goto OnBufferMoving;
    edge box7Clicked goto Removed;
    edge clicked? goto Removed;
  location OnBufferMoving:
    equation x' = Belt.speed,
             y' = 0.0;
    edge when x < bufferPos - if a_separator: 22 else 0 end goto OnBufferWaiting;
    edge ProductCounter.prodLeave when x > ProdBroadcast.lastXRemoved do bufferPos := max(bufferPos - 40, 681);
    edge box7Clicked goto Removed;
    edge clicked? goto Removed;
  location OnBufferWaiting:
    equation x' = 0.0,
             y' = 0.0;
    edge ProductCounter.prodLeave when bufferPos > 682 and x > ProdBroadcast.lastXRemoved do bufferPos := bufferPos - 40 goto OnBufferMoving;
    edge ProdBroadcast.prodUpdate! when a_separator and bufferPos < 682 goto ToSeperatorTransit;
    edge ProdBroadcast.prodDoUpdate goto OnBufferMoving;
    edge box7Clicked goto Removed;
    edge clicked? goto Removed;
  location ToSeperatorTransit:
    equation x' = Belt.speed,
             y' = 0.0;
    edge when x < 660 goto InSeperatorWaiting;
    edge box7Clicked goto Removed;
    edge clicked? goto Removed;
  location InSeperatorWaiting:
    equation x' = 0.0,
             y' = 0.0;
    edge ProdBroadcast.prodLeave!x when not a_separator goto BufferEndTransit;
    edge box7Clicked goto Removed;
    edge clicked? goto Removed;
  location BufferEndTransit:
    equation x' = -boxSpeed,
             y' = 0.0;
    edge when x < 546 goto Inactive;
    edge box7Clicked goto Removed;
    edge clicked? goto Removed;
  location Removed:
    equation x' = 0.0,
             y' = 0.0;
    edge ProdBroadcast.prodLeave!x do x := -200.0 goto Inactive;
end
automaton box8:
  monitor productRejected, ProductCounter.prodLeave, ProdBroadcast.prodDoUpdate, box8Clicked;
  event void clicked;
  cont x = -200.0;
  cont y = -200.0;
  disc string color = "pink";
  disc bool isThick = false;
  cont rotation = 0.0 der rotDer;
  disc real rotDer = 0.0;
  cont accelTimer = 1.0 der 1.0;
  alg real acccelSpeed = min(accelTimer * 2000.0, 800000.0) + boxSpeed;
  const real timeOnAirslide = 0.2;
  alg real slideAngle = 10 * 3.141592654 / 180;
  disc int productRejectPosX = 1138;
  disc int bufferPos;
  const int[1178..1178] productRejectStartX = 1178;
  const int[1138..1138] productConstRejectX = 1138;
  alg real boxSpeedInArm = 2 * 3.1415 * 181 / 360 * Arm.armSpeed;
  location Inactive:
    initial;
    equation x' = 0.0,
             y' = 0.0;
    edge spawn_new_block? do (x, y, color, isThick) := (?[bounds][x], ?[bounds][y], ?[color], ?[thick]), productRejectPosX := productConstRejectX, rotation := 0.0 goto InArm;
  location InArm:
    equation x' = -boxSpeedInArm * cos(Arm.armRot / 180 * 3.1415),
             y' = -boxSpeedInArm * sin(Arm.armRot / 180 * 3.1415);
    edge when isThick and y > Const.Box.LiftPos[y] + 23.0 * 0.2 do (x, y) := Const.Box.LiftPos goto InLift;
    edge when not isThick and y > Const.Box.LiftPos[y] do (x, y) := Const.Box.LiftPos goto InLift;
  location InLift:
    equation x' = 0.0,
             y' = Lift.speed;
    edge pusher_activated? when s_elevator_up do rotDer := -30.0 goto LiftSlideTransit;
    edge pusher_activated? when s_elevator_down goto PreRejectBufferTransit;
  location PreRejectBufferTransit:
    equation x' = -boxSpeed,
             y' = 0.0;
    edge RejectBuffer.preRejectEnter! when x < productRejectStartX goto RejectBufferTransit;
  location RejectBufferTransit:
    equation x' = -boxSpeed,
             y' = 0.0;
    edge when x < productRejectPosX goto OnRejectBuffer;
  location OnRejectBuffer:
    equation x' = 0.0,
             y' = 0.0;
    edge productRejected do productRejectPosX := productRejectPosX - Const.Box.Size goto RejectBufferTransit;
    edge when b_reset.Pressed goto AwaitResetRelease;
  location AwaitResetRelease:
    equation x' = 0.0,
             y' = 0.0;
    edge when b_reset.Released do (x, y) := (-200.0, -200.0) goto Inactive;
  location LiftSlideTransit:
    equation x' = -boxSpeed * cos(slideAngle),
             y' = boxSpeed * sin(slideAngle);
    edge when rotation < -10 do rotDer := 0.0, accelTimer := 0.0 goto OnAirslide;
    edge box8Clicked goto Removed;
    edge clicked? goto Removed;
  location OnAirslide:
    equation x' = -acccelSpeed * cos(slideAngle),
             y' = acccelSpeed * sin(slideAngle);
    edge when y > Const.Box.BufferY do rotDer := boxSpeed goto SlideBufferTransit;
    edge box8Clicked goto Removed;
    edge clicked? goto Removed;
  location SlideBufferTransit:
    equation x' = -boxSpeed,
             y' = 0.0;
    edge ProductCounter.prodEnter! when rotation > 0 do rotDer := 0.0, bufferPos := ProductCounter.rightMostProdX goto OnBufferMoving;
    edge box8Clicked goto Removed;
    edge clicked? goto Removed;
  location OnBufferMoving:
    equation x' = Belt.speed,
             y' = 0.0;
    edge when x < bufferPos - if a_separator: 22 else 0 end goto OnBufferWaiting;
    edge ProductCounter.prodLeave when x > ProdBroadcast.lastXRemoved do bufferPos := max(bufferPos - 40, 681);
    edge box8Clicked goto Removed;
    edge clicked? goto Removed;
  location OnBufferWaiting:
    equation x' = 0.0,
             y' = 0.0;
    edge ProductCounter.prodLeave when bufferPos > 682 and x > ProdBroadcast.lastXRemoved do bufferPos := bufferPos - 40 goto OnBufferMoving;
    edge ProdBroadcast.prodUpdate! when a_separator and bufferPos < 682 goto ToSeperatorTransit;
    edge ProdBroadcast.prodDoUpdate goto OnBufferMoving;
    edge box8Clicked goto Removed;
    edge clicked? goto Removed;
  location ToSeperatorTransit:
    equation x' = Belt.speed,
             y' = 0.0;
    edge when x < 660 goto InSeperatorWaiting;
    edge box8Clicked goto Removed;
    edge clicked? goto Removed;
  location InSeperatorWaiting:
    equation x' = 0.0,
             y' = 0.0;
    edge ProdBroadcast.prodLeave!x when not a_separator goto BufferEndTransit;
    edge box8Clicked goto Removed;
    edge clicked? goto Removed;
  location BufferEndTransit:
    equation x' = -boxSpeed,
             y' = 0.0;
    edge when x < 546 goto Inactive;
    edge box8Clicked goto Removed;
    edge clicked? goto Removed;
  location Removed:
    equation x' = 0.0,
             y' = 0.0;
    edge ProdBroadcast.prodLeave!x do x := -200.0 goto Inactive;
end
automaton box9:
  monitor productRejected, ProductCounter.prodLeave, ProdBroadcast.prodDoUpdate, box9Clicked;
  event void clicked;
  cont x = -200.0;
  cont y = -200.0;
  disc string color = "pink";
  disc bool isThick = false;
  cont rotation = 0.0 der rotDer;
  disc real rotDer = 0.0;
  cont accelTimer = 1.0 der 1.0;
  alg real acccelSpeed = min(accelTimer * 2000.0, 800000.0) + boxSpeed;
  const real timeOnAirslide = 0.2;
  alg real slideAngle = 10 * 3.141592654 / 180;
  disc int productRejectPosX = 1138;
  disc int bufferPos;
  const int[1178..1178] productRejectStartX = 1178;
  const int[1138..1138] productConstRejectX = 1138;
  alg real boxSpeedInArm = 2 * 3.1415 * 181 / 360 * Arm.armSpeed;
  location Inactive:
    initial;
    equation x' = 0.0,
             y' = 0.0;
    edge spawn_new_block? do (x, y, color, isThick) := (?[bounds][x], ?[bounds][y], ?[color], ?[thick]), productRejectPosX := productConstRejectX, rotation := 0.0 goto InArm;
  location InArm:
    equation x' = -boxSpeedInArm * cos(Arm.armRot / 180 * 3.1415),
             y' = -boxSpeedInArm * sin(Arm.armRot / 180 * 3.1415);
    edge when isThick and y > Const.Box.LiftPos[y] + 23.0 * 0.2 do (x, y) := Const.Box.LiftPos goto InLift;
    edge when not isThick and y > Const.Box.LiftPos[y] do (x, y) := Const.Box.LiftPos goto InLift;
  location InLift:
    equation x' = 0.0,
             y' = Lift.speed;
    edge pusher_activated? when s_elevator_up do rotDer := -30.0 goto LiftSlideTransit;
    edge pusher_activated? when s_elevator_down goto PreRejectBufferTransit;
  location PreRejectBufferTransit:
    equation x' = -boxSpeed,
             y' = 0.0;
    edge RejectBuffer.preRejectEnter! when x < productRejectStartX goto RejectBufferTransit;
  location RejectBufferTransit:
    equation x' = -boxSpeed,
             y' = 0.0;
    edge when x < productRejectPosX goto OnRejectBuffer;
  location OnRejectBuffer:
    equation x' = 0.0,
             y' = 0.0;
    edge productRejected do productRejectPosX := productRejectPosX - Const.Box.Size goto RejectBufferTransit;
    edge when b_reset.Pressed goto AwaitResetRelease;
  location AwaitResetRelease:
    equation x' = 0.0,
             y' = 0.0;
    edge when b_reset.Released do (x, y) := (-200.0, -200.0) goto Inactive;
  location LiftSlideTransit:
    equation x' = -boxSpeed * cos(slideAngle),
             y' = boxSpeed * sin(slideAngle);
    edge when rotation < -10 do rotDer := 0.0, accelTimer := 0.0 goto OnAirslide;
    edge box9Clicked goto Removed;
    edge clicked? goto Removed;
  location OnAirslide:
    equation x' = -acccelSpeed * cos(slideAngle),
             y' = acccelSpeed * sin(slideAngle);
    edge when y > Const.Box.BufferY do rotDer := boxSpeed goto SlideBufferTransit;
    edge box9Clicked goto Removed;
    edge clicked? goto Removed;
  location SlideBufferTransit:
    equation x' = -boxSpeed,
             y' = 0.0;
    edge ProductCounter.prodEnter! when rotation > 0 do rotDer := 0.0, bufferPos := ProductCounter.rightMostProdX goto OnBufferMoving;
    edge box9Clicked goto Removed;
    edge clicked? goto Removed;
  location OnBufferMoving:
    equation x' = Belt.speed,
             y' = 0.0;
    edge when x < bufferPos - if a_separator: 22 else 0 end goto OnBufferWaiting;
    edge ProductCounter.prodLeave when x > ProdBroadcast.lastXRemoved do bufferPos := max(bufferPos - 40, 681);
    edge box9Clicked goto Removed;
    edge clicked? goto Removed;
  location OnBufferWaiting:
    equation x' = 0.0,
             y' = 0.0;
    edge ProductCounter.prodLeave when bufferPos > 682 and x > ProdBroadcast.lastXRemoved do bufferPos := bufferPos - 40 goto OnBufferMoving;
    edge ProdBroadcast.prodUpdate! when a_separator and bufferPos < 682 goto ToSeperatorTransit;
    edge ProdBroadcast.prodDoUpdate goto OnBufferMoving;
    edge box9Clicked goto Removed;
    edge clicked? goto Removed;
  location ToSeperatorTransit:
    equation x' = Belt.speed,
             y' = 0.0;
    edge when x < 660 goto InSeperatorWaiting;
    edge box9Clicked goto Removed;
    edge clicked? goto Removed;
  location InSeperatorWaiting:
    equation x' = 0.0,
             y' = 0.0;
    edge ProdBroadcast.prodLeave!x when not a_separator goto BufferEndTransit;
    edge box9Clicked goto Removed;
    edge clicked? goto Removed;
  location BufferEndTransit:
    equation x' = -boxSpeed,
             y' = 0.0;
    edge when x < 546 goto Inactive;
    edge box9Clicked goto Removed;
    edge clicked? goto Removed;
  location Removed:
    equation x' = 0.0,
             y' = 0.0;
    edge ProdBroadcast.prodLeave!x do x := -200.0 goto Inactive;
end
automaton box10:
  monitor productRejected, ProductCounter.prodLeave, ProdBroadcast.prodDoUpdate, box10Clicked;
  event void clicked;
  cont x = -200.0;
  cont y = -200.0;
  disc string color = "pink";
  disc bool isThick = false;
  cont rotation = 0.0 der rotDer;
  disc real rotDer = 0.0;
  cont accelTimer = 1.0 der 1.0;
  alg real acccelSpeed = min(accelTimer * 2000.0, 800000.0) + boxSpeed;
  const real timeOnAirslide = 0.2;
  alg real slideAngle = 10 * 3.141592654 / 180;
  disc int productRejectPosX = 1138;
  disc int bufferPos;
  const int[1178..1178] productRejectStartX = 1178;
  const int[1138..1138] productConstRejectX = 1138;
  alg real boxSpeedInArm = 2 * 3.1415 * 181 / 360 * Arm.armSpeed;
  location Inactive:
    initial;
    equation x' = 0.0,
             y' = 0.0;
    edge spawn_new_block? do (x, y, color, isThick) := (?[bounds][x], ?[bounds][y], ?[color], ?[thick]), productRejectPosX := productConstRejectX, rotation := 0.0 goto InArm;
  location InArm:
    equation x' = -boxSpeedInArm * cos(Arm.armRot / 180 * 3.1415),
             y' = -boxSpeedInArm * sin(Arm.armRot / 180 * 3.1415);
    edge when isThick and y > Const.Box.LiftPos[y] + 23.0 * 0.2 do (x, y) := Const.Box.LiftPos goto InLift;
    edge when not isThick and y > Const.Box.LiftPos[y] do (x, y) := Const.Box.LiftPos goto InLift;
  location InLift:
    equation x' = 0.0,
             y' = Lift.speed;
    edge pusher_activated? when s_elevator_up do rotDer := -30.0 goto LiftSlideTransit;
    edge pusher_activated? when s_elevator_down goto PreRejectBufferTransit;
  location PreRejectBufferTransit:
    equation x' = -boxSpeed,
             y' = 0.0;
    edge RejectBuffer.preRejectEnter! when x < productRejectStartX goto RejectBufferTransit;
  location RejectBufferTransit:
    equation x' = -boxSpeed,
             y' = 0.0;
    edge when x < productRejectPosX goto OnRejectBuffer;
  location OnRejectBuffer:
    equation x' = 0.0,
             y' = 0.0;
    edge productRejected do productRejectPosX := productRejectPosX - Const.Box.Size goto RejectBufferTransit;
    edge when b_reset.Pressed goto AwaitResetRelease;
  location AwaitResetRelease:
    equation x' = 0.0,
             y' = 0.0;
    edge when b_reset.Released do (x, y) := (-200.0, -200.0) goto Inactive;
  location LiftSlideTransit:
    equation x' = -boxSpeed * cos(slideAngle),
             y' = boxSpeed * sin(slideAngle);
    edge when rotation < -10 do rotDer := 0.0, accelTimer := 0.0 goto OnAirslide;
    edge box10Clicked goto Removed;
    edge clicked? goto Removed;
  location OnAirslide:
    equation x' = -acccelSpeed * cos(slideAngle),
             y' = acccelSpeed * sin(slideAngle);
    edge when y > Const.Box.BufferY do rotDer := boxSpeed goto SlideBufferTransit;
    edge box10Clicked goto Removed;
    edge clicked? goto Removed;
  location SlideBufferTransit:
    equation x' = -boxSpeed,
             y' = 0.0;
    edge ProductCounter.prodEnter! when rotation > 0 do rotDer := 0.0, bufferPos := ProductCounter.rightMostProdX goto OnBufferMoving;
    edge box10Clicked goto Removed;
    edge clicked? goto Removed;
  location OnBufferMoving:
    equation x' = Belt.speed,
             y' = 0.0;
    edge when x < bufferPos - if a_separator: 22 else 0 end goto OnBufferWaiting;
    edge ProductCounter.prodLeave when x > ProdBroadcast.lastXRemoved do bufferPos := max(bufferPos - 40, 681);
    edge box10Clicked goto Removed;
    edge clicked? goto Removed;
  location OnBufferWaiting:
    equation x' = 0.0,
             y' = 0.0;
    edge ProductCounter.prodLeave when bufferPos > 682 and x > ProdBroadcast.lastXRemoved do bufferPos := bufferPos - 40 goto OnBufferMoving;
    edge ProdBroadcast.prodUpdate! when a_separator and bufferPos < 682 goto ToSeperatorTransit;
    edge ProdBroadcast.prodDoUpdate goto OnBufferMoving;
    edge box10Clicked goto Removed;
    edge clicked? goto Removed;
  location ToSeperatorTransit:
    equation x' = Belt.speed,
             y' = 0.0;
    edge when x < 660 goto InSeperatorWaiting;
    edge box10Clicked goto Removed;
    edge clicked? goto Removed;
  location InSeperatorWaiting:
    equation x' = 0.0,
             y' = 0.0;
    edge ProdBroadcast.prodLeave!x when not a_separator goto BufferEndTransit;
    edge box10Clicked goto Removed;
    edge clicked? goto Removed;
  location BufferEndTransit:
    equation x' = -boxSpeed,
             y' = 0.0;
    edge when x < 546 goto Inactive;
    edge box10Clicked goto Removed;
    edge clicked? goto Removed;
  location Removed:
    equation x' = 0.0,
             y' = 0.0;
    edge ProdBroadcast.prodLeave!x do x := -200.0 goto Inactive;
end
group box1_svg:
  alg string name = "Product_" + <string>idfier;
  alg real heightScale = if data[thick]: 1.2 else 1.0 end;
  alg int idfier = 1;
  alg BoxData data = BoxUpdater.data[0];
  svgcopy id "Product" post "_" + <string>idfier file "../SystemSVG.svg";
  svgin id name event box1Clicked file "../SystemSVG.svg";
  svgout id name attr "transform" value fmt("translate(%f, %f) rotate(%f)", data[bounds][x], data[bounds][y], data[rotation]) file "../SystemSVG.svg";
  svgout id "ProductGraphics_" + <string>idfier attr "fill" value data[color] file "../SystemSVG.svg";
  svgout id "ProductGraphics_" + <string>idfier attr "transform" value fmt("matrix(1,0,0,%f,0,%f)", heightScale, -(heightScale - 1.0) * 23) file "../SystemSVG.svg";
end
group box2_svg:
  alg string name = "Product_" + <string>idfier;
  alg real heightScale = if data[thick]: 1.2 else 1.0 end;
  alg int idfier = 2;
  alg BoxData data = BoxUpdater.data[1];
  svgcopy id "Product" post "_" + <string>idfier file "../SystemSVG.svg";
  svgin id name event box2Clicked file "../SystemSVG.svg";
  svgout id name attr "transform" value fmt("translate(%f, %f) rotate(%f)", data[bounds][x], data[bounds][y], data[rotation]) file "../SystemSVG.svg";
  svgout id "ProductGraphics_" + <string>idfier attr "fill" value data[color] file "../SystemSVG.svg";
  svgout id "ProductGraphics_" + <string>idfier attr "transform" value fmt("matrix(1,0,0,%f,0,%f)", heightScale, -(heightScale - 1.0) * 23) file "../SystemSVG.svg";
end
group box3_svg:
  alg string name = "Product_" + <string>idfier;
  alg real heightScale = if data[thick]: 1.2 else 1.0 end;
  alg int idfier = 3;
  alg BoxData data = BoxUpdater.data[2];
  svgcopy id "Product" post "_" + <string>idfier file "../SystemSVG.svg";
  svgin id name event box3Clicked file "../SystemSVG.svg";
  svgout id name attr "transform" value fmt("translate(%f, %f) rotate(%f)", data[bounds][x], data[bounds][y], data[rotation]) file "../SystemSVG.svg";
  svgout id "ProductGraphics_" + <string>idfier attr "fill" value data[color] file "../SystemSVG.svg";
  svgout id "ProductGraphics_" + <string>idfier attr "transform" value fmt("matrix(1,0,0,%f,0,%f)", heightScale, -(heightScale - 1.0) * 23) file "../SystemSVG.svg";
end
group box4_svg:
  alg string name = "Product_" + <string>idfier;
  alg real heightScale = if data[thick]: 1.2 else 1.0 end;
  alg int idfier = 4;
  alg BoxData data = BoxUpdater.data[3];
  svgcopy id "Product" post "_" + <string>idfier file "../SystemSVG.svg";
  svgin id name event box4Clicked file "../SystemSVG.svg";
  svgout id name attr "transform" value fmt("translate(%f, %f) rotate(%f)", data[bounds][x], data[bounds][y], data[rotation]) file "../SystemSVG.svg";
  svgout id "ProductGraphics_" + <string>idfier attr "fill" value data[color] file "../SystemSVG.svg";
  svgout id "ProductGraphics_" + <string>idfier attr "transform" value fmt("matrix(1,0,0,%f,0,%f)", heightScale, -(heightScale - 1.0) * 23) file "../SystemSVG.svg";
end
group box5_svg:
  alg string name = "Product_" + <string>idfier;
  alg real heightScale = if data[thick]: 1.2 else 1.0 end;
  alg int idfier = 5;
  alg BoxData data = BoxUpdater.data[4];
  svgcopy id "Product" post "_" + <string>idfier file "../SystemSVG.svg";
  svgin id name event box5Clicked file "../SystemSVG.svg";
  svgout id name attr "transform" value fmt("translate(%f, %f) rotate(%f)", data[bounds][x], data[bounds][y], data[rotation]) file "../SystemSVG.svg";
  svgout id "ProductGraphics_" + <string>idfier attr "fill" value data[color] file "../SystemSVG.svg";
  svgout id "ProductGraphics_" + <string>idfier attr "transform" value fmt("matrix(1,0,0,%f,0,%f)", heightScale, -(heightScale - 1.0) * 23) file "../SystemSVG.svg";
end
group box6_svg:
  alg string name = "Product_" + <string>idfier;
  alg real heightScale = if data[thick]: 1.2 else 1.0 end;
  alg int idfier = 6;
  alg BoxData data = BoxUpdater.data[5];
  svgcopy id "Product" post "_" + <string>idfier file "../SystemSVG.svg";
  svgin id name event box6Clicked file "../SystemSVG.svg";
  svgout id name attr "transform" value fmt("translate(%f, %f) rotate(%f)", data[bounds][x], data[bounds][y], data[rotation]) file "../SystemSVG.svg";
  svgout id "ProductGraphics_" + <string>idfier attr "fill" value data[color] file "../SystemSVG.svg";
  svgout id "ProductGraphics_" + <string>idfier attr "transform" value fmt("matrix(1,0,0,%f,0,%f)", heightScale, -(heightScale - 1.0) * 23) file "../SystemSVG.svg";
end
group box7_svg:
  alg string name = "Product_" + <string>idfier;
  alg real heightScale = if data[thick]: 1.2 else 1.0 end;
  alg int idfier = 7;
  alg BoxData data = BoxUpdater.data[6];
  svgcopy id "Product" post "_" + <string>idfier file "../SystemSVG.svg";
  svgin id name event box7Clicked file "../SystemSVG.svg";
  svgout id name attr "transform" value fmt("translate(%f, %f) rotate(%f)", data[bounds][x], data[bounds][y], data[rotation]) file "../SystemSVG.svg";
  svgout id "ProductGraphics_" + <string>idfier attr "fill" value data[color] file "../SystemSVG.svg";
  svgout id "ProductGraphics_" + <string>idfier attr "transform" value fmt("matrix(1,0,0,%f,0,%f)", heightScale, -(heightScale - 1.0) * 23) file "../SystemSVG.svg";
end
group box8_svg:
  alg string name = "Product_" + <string>idfier;
  alg real heightScale = if data[thick]: 1.2 else 1.0 end;
  alg int idfier = 8;
  alg BoxData data = BoxUpdater.data[7];
  svgcopy id "Product" post "_" + <string>idfier file "../SystemSVG.svg";
  svgin id name event box8Clicked file "../SystemSVG.svg";
  svgout id name attr "transform" value fmt("translate(%f, %f) rotate(%f)", data[bounds][x], data[bounds][y], data[rotation]) file "../SystemSVG.svg";
  svgout id "ProductGraphics_" + <string>idfier attr "fill" value data[color] file "../SystemSVG.svg";
  svgout id "ProductGraphics_" + <string>idfier attr "transform" value fmt("matrix(1,0,0,%f,0,%f)", heightScale, -(heightScale - 1.0) * 23) file "../SystemSVG.svg";
end
group box9_svg:
  alg string name = "Product_" + <string>idfier;
  alg real heightScale = if data[thick]: 1.2 else 1.0 end;
  alg int idfier = 9;
  alg BoxData data = BoxUpdater.data[8];
  svgcopy id "Product" post "_" + <string>idfier file "../SystemSVG.svg";
  svgin id name event box9Clicked file "../SystemSVG.svg";
  svgout id name attr "transform" value fmt("translate(%f, %f) rotate(%f)", data[bounds][x], data[bounds][y], data[rotation]) file "../SystemSVG.svg";
  svgout id "ProductGraphics_" + <string>idfier attr "fill" value data[color] file "../SystemSVG.svg";
  svgout id "ProductGraphics_" + <string>idfier attr "transform" value fmt("matrix(1,0,0,%f,0,%f)", heightScale, -(heightScale - 1.0) * 23) file "../SystemSVG.svg";
end
group box10_svg:
  alg string name = "Product_" + <string>idfier;
  alg real heightScale = if data[thick]: 1.2 else 1.0 end;
  alg int idfier = 10;
  alg BoxData data = BoxUpdater.data[9];
  svgcopy id "Product" post "_" + <string>idfier file "../SystemSVG.svg";
  svgin id name event box10Clicked file "../SystemSVG.svg";
  svgout id name attr "transform" value fmt("translate(%f, %f) rotate(%f)", data[bounds][x], data[bounds][y], data[rotation]) file "../SystemSVG.svg";
  svgout id "ProductGraphics_" + <string>idfier attr "fill" value data[color] file "../SystemSVG.svg";
  svgout id "ProductGraphics_" + <string>idfier attr "transform" value fmt("matrix(1,0,0,%f,0,%f)", heightScale, -(heightScale - 1.0) * 23) file "../SystemSVG.svg";
end
automaton ProdBroadcast:
  event real prodLeave;
  event void prodUpdate;
  event prodDoUpdate;
  disc real lastXRemoved;
  location Await:
    initial;
    edge prodLeave? do lastXRemoved := ? goto Send1;
    edge prodUpdate? goto Send2;
  location Send1:
    edge ProductCounter.prodLeave! goto Await;
  location Send2:
    edge prodDoUpdate goto Await;
end
automaton ProductCounter:
  disc int rightMostProdX = 681;
  event void prodEnter;
  event void prodLeave;
  location:
    initial;
    edge prodEnter? do rightMostProdX := rightMostProdX + 40;
    edge prodLeave? do rightMostProdX := max(rightMostProdX - 40, 681);
end
automaton b_start_B:
  event clicked;
  event void toggle;
  disc bool state = initialState;
  alg bool initialState = false;
  location Released:
    initial;
    edge clicked do state := true goto Pressed;
    edge toggle? do state := true goto Pressed;
  location Pressed:
    edge clicked do state := false goto Released;
    edge toggle? do state := false goto Released;
end
group b_start_B_svg:
  alg string idfier = "start_B";
  alg string onColor = "yellow";
  alg string offColor = "grey";
  alg bool state = b_start_B.state;
  svgin id idfier event b_start_B.clicked file "../SystemSVG.svg";
  svgout id idfier attr "fill" value if state: onColor else offColor end file "../SystemSVG.svg";
end
automaton b_start:
  event clicked;
  event void toggle;
  disc bool state = initialState;
  alg bool initialState = false;
  location Released:
    initial;
    edge clicked do state := true goto Pressed;
    edge toggle? do state := true goto Pressed;
  location Pressed:
    edge clicked do state := false goto Released;
    edge toggle? do state := false goto Released;
end
group b_start_svg:
  alg string idfier = "start";
  alg string onColor = "yellow";
  alg string offColor = "grey";
  alg bool state = b_start.state;
  svgin id idfier event b_start.clicked file "../SystemSVG.svg";
  svgout id idfier attr "fill" value if state: onColor else offColor end file "../SystemSVG.svg";
end
automaton b_reset:
  event clicked;
  event void toggle;
  disc bool state = initialState;
  alg bool initialState = false;
  location Released:
    initial;
    edge clicked do state := true goto Pressed;
    edge toggle? do state := true goto Pressed;
  location Pressed:
    edge clicked do state := false goto Released;
    edge toggle? do state := false goto Released;
end
group b_reset_svg:
  alg string idfier = "b_reset";
  alg string onColor = "yellow";
  alg string offColor = "grey";
  alg bool state = b_reset.state;
  svgin id idfier event b_reset.clicked file "../SystemSVG.svg";
  svgout id idfier attr "fill" value if state: onColor else offColor end file "../SystemSVG.svg";
end
automaton b_stop:
  event clicked;
  event void toggle;
  disc bool state = initialState;
  alg bool initialState = true;
  location Released:
    initial;
    edge clicked do state := true goto Pressed;
    edge toggle? do state := true goto Pressed;
  location Pressed:
    edge clicked do state := false goto Released;
    edge toggle? do state := false goto Released;
end
group stop_svg:
  alg string idfier = "stop";
  alg string onColor = "yellow";
  alg string offColor = "grey";
  alg bool state = b_stop.state;
  svgin id idfier event b_stop.clicked file "../SystemSVG.svg";
  svgout id idfier attr "fill" value if state: onColor else offColor end file "../SystemSVG.svg";
end
automaton b_s_lift_up:
  event clicked;
  event void toggle;
  disc bool state = initialState;
  alg bool initialState = false;
  location Released:
    initial;
    edge clicked do state := true goto Pressed;
    edge toggle? do state := true goto Pressed;
  location Pressed:
    edge clicked do state := false goto Released;
    edge toggle? do state := false goto Released;
end
group svg_s_lift_up:
  alg string idfier = "s_lift_up";
  alg string onColor = Const.Sensors.onColor;
  alg string offColor = Const.Sensors.offColor;
  alg bool state = s_elevator_up;
  svgin id idfier event b_s_lift_up.clicked file "../SystemSVG.svg";
  svgout id idfier attr "fill" value if b_s_lift_up.Pressed: "orange" elif state: onColor else offColor end file "../SystemSVG.svg";
end
automaton b_s_lift_down:
  event clicked;
  event void toggle;
  disc bool state = initialState;
  alg bool initialState = false;
  location Released:
    initial;
    edge clicked do state := true goto Pressed;
    edge toggle? do state := true goto Pressed;
  location Pressed:
    edge clicked do state := false goto Released;
    edge toggle? do state := false goto Released;
end
group svg_s_lift_down:
  alg string idfier = "s_lift_down";
  alg string onColor = Const.Sensors.onColor;
  alg string offColor = Const.Sensors.offColor;
  alg bool state = s_elevator_down;
  svgin id idfier event b_s_lift_down.clicked file "../SystemSVG.svg";
  svgout id idfier attr "fill" value if b_s_lift_down.Pressed: "orange" elif state: onColor else offColor end file "../SystemSVG.svg";
end
automaton b_color:
  event clicked;
  event void toggle;
  disc bool state = initialState;
  alg bool initialState = false;
  location Released:
    initial;
    edge clicked do state := true goto Pressed;
    edge toggle? do state := true goto Pressed;
  location Pressed:
    edge clicked do state := false goto Released;
    edge toggle? do state := false goto Released;
end
group svg_b_color:
  alg bool state = b_color.state;
  svgin id "b_colour" event b_color.clicked file "../SystemSVG.svg";
  svgout id "colour_knob" attr "transform" value if state: "rotate(180,4.5,4.5)" else "" end file "../SystemSVG.svg";
end
automaton b_height:
  event clicked;
  event void toggle;
  disc bool state = initialState;
  alg bool initialState = false;
  location Released:
    initial;
    edge clicked do state := true goto Pressed;
    edge toggle? do state := true goto Pressed;
  location Pressed:
    edge clicked do state := false goto Released;
    edge toggle? do state := false goto Released;
end
automaton svg_b_height:
  const list real SwitchHeightHeights = [0.5, 3.25, 6.25];
  disc int state = 0;
  svgin id "b_height" event b_height.clicked file "../SystemSVG.svg";
  svgout id "height_bar" attr "transform" value fmt("translate(0, %f)", SwitchHeightHeights[state]) file "../SystemSVG.svg";
  svgout id "height_pole" attr "transform" value fmt("rotate(%d,0.5,2.5)", 90 * state) file "../SystemSVG.svg";
  location:
    initial;
    edge b_height.clicked do state := (state + 1) mod 3;
end
group svg_s_height:
  alg string idfier = "s_height";
  alg string onColor = Const.Sensors.onColor;
  alg string offColor = Const.Sensors.offColor;
  alg bool state = HeightSensor.isActive;
  svgout id idfier attr "fill" value if state: onColor else offColor end file "../SystemSVG.svg";
end
group svg_s_height2:
  alg string idfier = "s_height2";
  alg string onColor = "red";
  alg string offColor = "grey";
  alg bool state = HeightSensor.isActive;
  svgout id idfier attr "fill" value if state: onColor else offColor end file "../SystemSVG.svg";
end
group svg_s_capacitive:
  alg string idfier = "s_capacitive";
  alg string onColor = Const.Sensors.onColor;
  alg string offColor = Const.Sensors.offColor;
  alg bool state = CapacitiveSensor.isActive;
  svgout id idfier attr "fill" value if state: onColor else offColor end file "../SystemSVG.svg";
end
group svg_s_reflective:
  alg string idfier = "s_reflective";
  alg string onColor = Const.Sensors.onColor;
  alg string offColor = Const.Sensors.offColor;
  alg bool state = ReflexiveSensor.isActive;
  svgout id idfier attr "fill" value if state: onColor else offColor end file "../SystemSVG.svg";
end
group svg_s_optical:
  alg string idfier = "s_optical";
  alg string onColor = Const.Sensors.onColor;
  alg string offColor = Const.Sensors.offColor;
  alg bool state = OpticalSensor.isActive;
  svgout id idfier attr "fill" value if state: onColor else offColor end file "../SystemSVG.svg";
end
automaton b_spawn:
  event clicked;
  event void toggle;
  disc bool state = initialState;
  alg bool initialState = false;
  location Released:
    initial;
    edge clicked do state := true goto Pressed;
    edge toggle? do state := true goto Pressed;
  location Pressed:
    edge clicked do state := false goto Released;
    edge toggle? do state := false goto Released;
end
group svg_b_spawn:
  alg string idfier = "b_spawn";
  alg string onColor = "yellow";
  alg string offColor = "grey";
  alg bool state = b_spawn.state;
  svgin id idfier event b_spawn.clicked file "../SystemSVG.svg";
  svgout id idfier attr "fill" value if state: onColor else offColor end file "../SystemSVG.svg";
end
automaton b_autoManualSwitch:
  event clicked;
  event void toggle;
  disc bool state = initialState;
  alg bool initialState = false;
  location Released:
    initial;
    edge clicked do state := true goto Pressed;
    edge toggle? do state := true goto Pressed;
  location Pressed:
    edge clicked do state := false goto Released;
    edge toggle? do state := false goto Released;
end
group svg_b_autoManualSwitch:
  alg string idfier = "key";
  alg string onColor = "yellow";
  alg string offColor = "grey";
  alg bool state = b_autoManualSwitch.state;
  svgin id idfier event b_autoManualSwitch.clicked file "../SystemSVG.svg";
  svgout id idfier attr "fill" value if state: onColor else offColor end file "../SystemSVG.svg";
end
automaton b_s_pusher:
  event clicked;
  event void toggle;
  disc bool state = initialState;
  alg bool initialState = false;
  location Released:
    initial;
    edge clicked do state := true goto Pressed;
    edge toggle? do state := true goto Pressed;
  location Pressed:
    edge clicked do state := false goto Released;
    edge toggle? do state := false goto Released;
end
group svg_s_pusher:
  alg string idfier = "s_pusher";
  alg string onColor = Const.Sensors.onColor;
  alg string offColor = Const.Sensors.offColor;
  alg bool state = s_pusher;
  svgin id idfier event b_s_pusher.clicked file "../SystemSVG.svg";
  svgout id idfier attr "fill" value if b_s_pusher.Pressed: "orange" elif state: onColor else offColor end file "../SystemSVG.svg";
end
automaton SysState:
  alg string state;
  location Off:
    initial;
    equation state = "Off";
    edge when s_Tstartbutton goto WaitForRelease;
  location WaitForRelease:
    equation state = "Off";
    edge when not s_Tstartbutton goto On;
  location On:
    equation state = if s_Tautoswitch: "Auto" else "Manual" end;
    edge when s_Tstopbutton goto WaitForStopRelease;
  location WaitForStopRelease:
    equation state = if s_Tautoswitch: "Auto" else "Manual" end;
    edge when not s_Tstopbutton goto Off;
end
automaton BoxUpdater:
  alg list[10] BoxData data;
  alg list[10] Rectangle rects;
  location:
    initial;
    equation data = [((box1.x, box1.y, 40.0, 23.0), box1.color, box1.isThick, box1.rotation), ((box2.x, box2.y, 40.0, 23.0), box2.color, box2.isThick, box2.rotation), ((box3.x, box3.y, 40.0, 23.0), box3.color, box3.isThick, box3.rotation), ((box4.x, box4.y, 40.0, 23.0), box4.color, box4.isThick, box4.rotation), ((box5.x, box5.y, 40.0, 23.0), box5.color, box5.isThick, box5.rotation), ((box6.x, box6.y, 40.0, 23.0), box6.color, box6.isThick, box6.rotation), ((box7.x, box7.y, 40.0, 23.0), box7.color, box7.isThick, box7.rotation), ((box8.x, box8.y, 40.0, 23.0), box8.color, box8.isThick, box8.rotation), ((box9.x, box9.y, 40.0, 23.0), box9.color, box9.isThick, box9.rotation), ((box10.x, box10.y, 40.0, 23.0), box10.color, box10.isThick, box10.rotation)],
             rects = [(box1.x, box1.y, 40.0, 23.0), (box2.x, box2.y, 40.0, 23.0), (box3.x, box3.y, 40.0, 23.0), (box4.x, box4.y, 40.0, 23.0), (box5.x, box5.y, 40.0, 23.0), (box6.x, box6.y, 40.0, 23.0), (box7.x, box7.y, 40.0, 23.0), (box8.x, box8.y, 40.0, 23.0), (box9.x, box9.y, 40.0, 23.0), (box10.x, box10.y, 40.0, 23.0)];
end
automaton RejectBuffer:
  event void preRejectEnter;
  location Await:
    initial;
    edge preRejectEnter? goto Send;
  location Send:
    edge productRejected goto Await;
end
automaton Lift:
  const real maxSpeed = 80.0;
  alg real speed;
  cont y der speed;
  alg bool liftAtTop = y <= -Const.Lift.MaxHeight;
  alg bool liftAtBot = y >= 0;
  location Up:
    equation speed = -maxSpeed;
    edge when not a_elevator_up goto Stop;
    edge when liftAtTop goto Stop;
  location Stop:
    initial;
    equation speed = 0.0;
    edge when a_elevator_up and not liftAtTop goto Up;
    edge when a_elevator_down and not liftAtBot goto Down;
  location Down:
    equation speed = maxSpeed;
    edge when not a_elevator_down goto Stop;
    edge when liftAtBot goto Stop;
end
automaton Pusher:
  alg real speed;
  cont x der speed;
  alg bool pusherExtend = Extending and x < -35;
  location Extending:
    equation speed = if not pusherExtend: -boxSpeed else 0.0 end;
    edge when not a_pusher goto Retracting;
  location Retracting:
    initial;
    equation speed = if x < 0: boxSpeed else 0.0 end;
    edge pusher_activated! when a_pusher goto Extending;
end
automaton HeightSensor:
  alg int boxI = RectRectColl(Const.Sensors.HeightBounds, BoxUpdater.data);
  alg bool isActive = boxI != -1 and not BoxUpdater.data[boxI][thick];
  cont y;
  location:
    initial;
    equation y' = if boxI != -1: Lift.speed elif y < 0: 10.0 else 0.0 end;
end
group CapacitiveSensor:
  alg int boxI = RectRectColl((Const.Sensors.CapSensorBounds[x], Const.Sensors.CapSensorBounds[y] + Lift.y, Const.Sensors.CapSensorBounds[width], Const.Sensors.CapSensorBounds[height]), BoxUpdater.data);
  alg bool isActive = boxI != -1;
end
group OpticalSensor:
  alg int boxI = RectRectColl((Const.Sensors.CapSensorBounds[x], Const.Sensors.CapSensorBounds[y] + Lift.y, Const.Sensors.CapSensorBounds[width], Const.Sensors.CapSensorBounds[height]), BoxUpdater.data);
  alg bool isActive = boxI != -1 and BoxUpdater.data[boxI][color] != "black";
end
group ReflexiveSensor:
  alg bool isActive = Arm.armRot < 130;
end
automaton Arm:
  cont armRot = 180.0 der armSpeed;
  disc real armSpeed = 0.0;
  location Waiting:
    initial;
    edge spawn_new_block when a_testingready do armSpeed := -100.0 goto Placing;
  location Returning:
    edge when armRot > 180 do armSpeed := 0.0 goto Waiting;
  location Placing:
    edge when armRot < 99 do armSpeed := 100.0 goto Returning;
end
automaton Factory:
  monitor b_spawn.clicked;
  disc string boxColor;
  disc bool isBlack;
  disc bool isThick;
  alg string boxColorMan = if b_color.Released: "black" else "red" end;
  alg string boxColorAuto = if isBlack: "black" else "red" end;
  alg bool isThickMan = svg_b_height.state = 0;
  disc dist bool thickDistrC1 = bernoulli(0.0);
  disc dist bool thickDistrC2 = bernoulli(0.3);
  disc dist bool thickDistrC3 = bernoulli(0.05);
  disc dist bool blackDistrC1 = bernoulli(0.0);
  disc dist bool blackDistrC2 = bernoulli(0.3);
  disc dist bool blackDistrC3 = bernoulli(0.05);
  cont timer der -1.0;
  location Waiting:
    initial;
    edge b_spawn.clicked when a_testingready and UseCase.NoCase do (boxColor, isThick) := (boxColorMan, isThickMan) goto SpawnBlock;
    edge when a_testingready and timer < 0 and UseCase.Case1 do (isThick, thickDistrC1) := sample thickDistrC1, (isBlack, blackDistrC1) := sample blackDistrC1 goto Inter;
    edge when a_testingready and timer < 0 and UseCase.Case2 do (isThick, thickDistrC2) := sample thickDistrC2, (isBlack, blackDistrC2) := sample blackDistrC2 goto Inter;
    edge when a_testingready and timer < 0 and UseCase.Case3 do (isThick, thickDistrC3) := sample thickDistrC3, (isBlack, blackDistrC3) := sample blackDistrC1 goto Inter;
  location Inter:
    edge do boxColor := boxColorAuto goto SpawnBlock;
  location SpawnBlock:
    edge spawn_new_block!(Const.Box.StartThickBounds, boxColor, isThick, 0.0) when isThick goto Post;
    edge spawn_new_block!(Const.Box.StartBounds, boxColor, isThick, 0.0) when not isThick goto Post;
  location Post:
    edge do timer := 3.0 goto Waiting;
end
automaton b_case1:
  event clicked;
  event void toggle;
  disc bool state = initialState;
  alg bool initialState = false;
  location Released:
    initial;
    edge clicked do state := true goto Pressed;
    edge toggle? do state := true goto Pressed;
  location Pressed:
    edge clicked do state := false goto Released;
    edge toggle? do state := false goto Released;
end
group b_case1_svg:
  alg string idfier = "b_case1";
  alg string onColor = "yellow";
  alg string offColor = "grey";
  alg bool state = b_case1.state;
  svgin id idfier event b_case1.clicked file "../SystemSVG.svg";
  svgout id idfier attr "fill" value if state: onColor else offColor end file "../SystemSVG.svg";
end
automaton b_case2:
  event clicked;
  event void toggle;
  disc bool state = initialState;
  alg bool initialState = false;
  location Released:
    initial;
    edge clicked do state := true goto Pressed;
    edge toggle? do state := true goto Pressed;
  location Pressed:
    edge clicked do state := false goto Released;
    edge toggle? do state := false goto Released;
end
group b_case2_svg:
  alg string idfier = "b_case2";
  alg string onColor = "yellow";
  alg string offColor = "grey";
  alg bool state = b_case2.state;
  svgin id idfier event b_case2.clicked file "../SystemSVG.svg";
  svgout id idfier attr "fill" value if state: onColor else offColor end file "../SystemSVG.svg";
end
automaton b_case3:
  event clicked;
  event void toggle;
  disc bool state = initialState;
  alg bool initialState = false;
  location Released:
    initial;
    edge clicked do state := true goto Pressed;
    edge toggle? do state := true goto Pressed;
  location Pressed:
    edge clicked do state := false goto Released;
    edge toggle? do state := false goto Released;
end
group b_case3_svg:
  alg string idfier = "b_case3";
  alg string onColor = "yellow";
  alg string offColor = "grey";
  alg bool state = b_case3.state;
  svgin id idfier event b_case3.clicked file "../SystemSVG.svg";
  svgout id idfier attr "fill" value if state: onColor else offColor end file "../SystemSVG.svg";
end
automaton UseCase:
  location Case1:
    initial;
    edge when b_case1.Released goto NoCase;
  location Case2:
    edge when b_case2.Released goto NoCase;
  location Case3:
    edge when b_case3.Released goto NoCase;
  location NoCase:
    edge when b_case1.Pressed goto Case1;
    edge when b_case2.Pressed goto Case2;
    edge when b_case3.Pressed goto Case3;
end
automaton Q1ResetPresser:
  cont timer der 1.0;
  location Init:
    initial;
    edge when not UseCase.NoCase and a_TledQ1 do timer := 0.0 goto Wait1;
  location Wait1:
    edge b_reset.toggle! when timer > 3 do timer := 0.0 goto Wait2;
  location Wait2:
    edge b_reset.toggle! when timer > 1 goto Init;
end
automaton ProdRemoval:
  cont timer der -1.0;
  location Init:
    initial;
    edge when UseCase.Case3 goto Stage1;
  location Stage1:
    edge when not UseCase.Case3 goto Init;
    edge box1.clicked! when box1.OnAirslide do timer := 3.0 goto Stage2;
    edge box2.clicked! when box2.OnAirslide do timer := 2.0 goto Stage2;
    edge box3.clicked! when box3.OnAirslide do timer := 1.0 goto Stage2;
    edge box4.clicked! when box4.OnAirslide do timer := 1.0 goto Stage2;
    edge box5.clicked! when box5.OnAirslide do timer := 1.0 goto Stage2;
    edge box6.clicked! when box6.OnAirslide do timer := 1.0 goto Stage2;
    edge box7.clicked! when box7.OnAirslide do timer := 1.0 goto Stage2;
    edge box8.clicked! when box8.OnAirslide do timer := 1.0 goto Stage2;
    edge box9.clicked! when box9.OnAirslide do timer := 1.0 goto Stage2;
    edge box10.clicked! when box10.OnAirslide do timer := 1.0 goto Stage2;
  location Stage2:
    edge when not UseCase.Case3 goto Init;
    edge box1.clicked! when box1.OnBufferMoving and timer < 0 goto Stage3;
    edge box2.clicked! when box2.OnBufferMoving and timer < 0 goto Stage3;
    edge box3.clicked! when box3.OnBufferMoving and timer < 0 goto Stage3;
    edge box4.clicked! when box4.OnBufferMoving and timer < 0 goto Stage3;
    edge box5.clicked! when box5.OnBufferMoving and timer < 0 goto Stage3;
  location Stage3:
    edge when not UseCase.Case3 goto Init;
    edge box1.clicked! when box1.InSeperatorWaiting goto Stage1;
    edge box2.clicked! when box2.InSeperatorWaiting goto Stage1;
    edge box3.clicked! when box3.InSeperatorWaiting goto Stage1;
    edge box4.clicked! when box4.InSeperatorWaiting goto Stage1;
    edge box5.clicked! when box5.InSeperatorWaiting goto Stage1;
end
automaton SensorMalfunctioner:
  cont timer der -1.0;
  location Init:
    initial;
    edge when UseCase.Case3 goto Stage1;
  location Stage1:
    edge when not UseCase.Case3 goto Init;
    edge b_s_lift_up.toggle! when Lift.Up do timer := 8.0 goto Stage2;
  location Stage2:
    edge b_s_lift_up.toggle! when timer < 0 goto Stage3;
  location Stage3:
    edge b_s_lift_down.toggle! when Lift.Down do timer := 8.0 goto Stage4;
  location Stage4:
    edge b_s_lift_down.toggle! when timer < 0 do timer := 12.0 goto Stage5;
  location Stage5:
    edge b_s_pusher.toggle! when timer < 0 do timer := 10.0 goto Stage6;
  location Stage6:
    edge b_s_pusher.toggle! when timer < 0 do timer := 25.0 goto Delay;
  location Delay:
    edge when timer < 0 goto Init;
end
automaton StartAutoPresser:
  cont timer der -1.0;
  location Init:
    initial;
    edge when a_TledQ2 and not UseCase.NoCase do timer := 2.0 goto PressStart;
  location PressStart:
    edge b_start.toggle! when timer < 0 do timer := 0.5 goto ReleaseStart;
  location ReleaseStart:
    edge b_start.toggle! when timer < 0 goto Init;
end
group svg_b_i_BS01:
  alg string idfier = "i_BS01";
  alg string onColor = "red";
  alg string offColor = "grey";
  alg bool state = s_product;
  svgout id idfier attr "fill" value if state: onColor else offColor end file "../SystemSVG.svg";
end
group svg_b_i_BS02:
  alg string idfier = "i_BS02";
  alg string onColor = "red";
  alg string offColor = "grey";
  alg bool state = s_atseparator;
  svgout id idfier attr "fill" value if state: onColor else offColor end file "../SystemSVG.svg";
end
group svg_b_i_BS03:
  alg string idfier = "i_BS03";
  alg string onColor = "red";
  alg string offColor = "grey";
  alg bool state = s_atexit;
  svgout id idfier attr "fill" value if state: onColor else offColor end file "../SystemSVG.svg";
end
group svg_s_product:
  alg string idfier = "s_product_entry";
  alg string onColor = Const.Sensors.onColor;
  alg string offColor = Const.Sensors.offColor;
  alg bool state = s_product;
  svgout id idfier attr "fill" value if state: onColor else offColor end file "../SystemSVG.svg";
end
group svg_s_atseparator:
  alg string idfier = "s_product_separator";
  alg string onColor = Const.Sensors.onColor;
  alg string offColor = Const.Sensors.offColor;
  alg bool state = s_atseparator;
  svgout id idfier attr "fill" value if state: onColor else offColor end file "../SystemSVG.svg";
end
group svg_s_atexit:
  alg string idfier = "s_product_exit";
  alg string onColor = Const.Sensors.onColor;
  alg string offColor = Const.Sensors.offColor;
  alg bool state = s_atexit;
  svgout id idfier attr "fill" value if state: onColor else offColor end file "../SystemSVG.svg";
end
group svg_s_separator_opened:
  alg string idfier = "s_separator_opened";
  alg string onColor = Const.Sensors.onColor;
  alg string offColor = Const.Sensors.offColor;
  alg bool state = Separator.Left;
  svgout id idfier attr "fill" value if state: onColor else offColor end file "../SystemSVG.svg";
end
group svg_s_separator_closed:
  alg string idfier = "s_separator_closed";
  alg string onColor = Const.Sensors.onColor;
  alg string offColor = Const.Sensors.offColor;
  alg bool state = Separator.Right;
  svgout id idfier attr "fill" value if state: onColor else offColor end file "../SystemSVG.svg";
end
group svg_s_Q1B:
  alg string idfier = "s_q1-7";
  alg string onColor = "yellow";
  alg string offColor = "grey";
  alg bool state = a_BledQ1;
  svgout id idfier attr "fill" value if state: onColor else offColor end file "../SystemSVG.svg";
end
group svg_s_Q2B:
  alg string idfier = "s_q2-5";
  alg string onColor = "yellow";
  alg string offColor = "grey";
  alg bool state = a_BledQ2;
  svgout id idfier attr "fill" value if state: onColor else offColor end file "../SystemSVG.svg";
end
group svg_b_processing:
  alg string idfier = "s_processing_busy";
  alg string onColor = Const.Sensors.onColor;
  alg string offColor = Const.Sensors.offColor;
  alg bool state = s_processingbusy;
  svgout id idfier attr "fill" value if state: onColor else offColor end file "../SystemSVG.svg";
end
automaton b_conveyer:
  event clicked;
  event void toggle;
  disc bool state = initialState;
  alg bool initialState = false;
  location Released:
    initial;
    edge clicked do state := true goto Pressed;
    edge toggle? do state := true goto Pressed;
  location Pressed:
    edge clicked do state := false goto Released;
    edge toggle? do state := false goto Released;
end
group svg_b_conveyer:
  alg string idfier = "b_conveyor";
  alg string onColor = "yellow";
  alg string offColor = "grey";
  alg bool state = b_conveyer.state;
  svgin id idfier event b_conveyer.clicked file "../SystemSVG.svg";
  svgout id idfier attr "fill" value if state: onColor else offColor end file "../SystemSVG.svg";
end
group svg_conv:
  alg int idfier = 1;
  alg real wheelRotation = Belt.wheelRotation;
  svgout id fmt("Conv%d_Wheel", idfier) attr "transform" value fmt("rotate(%d)", round(wheelRotation) mod 360) file "../SystemSVG.svg";
  svgout id fmt("Conv%d_Wheel2", idfier) attr "transform" value fmt("rotate(%d)", round(wheelRotation) mod 360) file "../SystemSVG.svg";
end
automaton b_reset_B:
  event clicked;
  event void toggle;
  disc bool state = initialState;
  alg bool initialState = false;
  location Released:
    initial;
    edge clicked do state := true goto Pressed;
    edge toggle? do state := true goto Pressed;
  location Pressed:
    edge clicked do state := false goto Released;
    edge toggle? do state := false goto Released;
end
group svg_b_reset_B:
  alg string idfier = "reset_B";
  alg string onColor = "yellow";
  alg string offColor = "grey";
  alg bool state = b_reset_B.state;
  svgin id idfier event b_reset_B.clicked file "../SystemSVG.svg";
  svgout id idfier attr "fill" value if state: onColor else offColor end file "../SystemSVG.svg";
end
automaton b_BautoManualSwitch:
  event clicked;
  event void toggle;
  disc bool state = initialState;
  alg bool initialState = false;
  location Released:
    initial;
    edge clicked do state := true goto Pressed;
    edge toggle? do state := true goto Pressed;
  location Pressed:
    edge clicked do state := false goto Released;
    edge toggle? do state := false goto Released;
end
group svg_b_BautoManualSwitch:
  alg string idfier = "key-2";
  alg string onColor = "yellow";
  alg string offColor = "grey";
  alg bool state = b_autoManualSwitch.state;
  svgin id idfier event b_BautoManualSwitch.clicked file "../SystemSVG.svg";
  svgout id idfier attr "fill" value if state: onColor else offColor end file "../SystemSVG.svg";
end
automaton ProcessingBusySensor:
  cont timer der -1.0;
  location On:
    edge when UseCase.NoCase goto Off;
    edge when UseCase.Case1 and timer < 0 do timer := 3.0 goto Off;
    edge when UseCase.Case2 and timer < 0 do timer := 3.0 goto Off;
    edge when UseCase.Case3 and timer < 0 do timer := 3.0 goto Off;
  location Off:
    initial;
    edge when UseCase.Case1 and timer < 0 do timer := 10.0 goto On;
    edge when UseCase.Case2 and timer < 0 do timer := 3.0 goto On;
    edge when UseCase.Case3 and timer < 0 do timer := 3.0 goto On;
end
automaton Belt:
  cont wheelRotation der 3.0 * speed;
  alg real speed;
  cont x der speed;
  location Moving:
    equation speed = -80.0;
    edge when not a_conveyer goto Standstill;
  location Standstill:
    initial;
    equation speed = 0.0;
    edge when a_conveyer goto Moving;
end
automaton Separator:
  location Right:
    edge when not a_separator goto Left;
  location Left:
    initial;
    edge when a_separator goto Right;
end
automaton Q2ResetPresser:
  cont timer der 1.0;
  location Init:
    initial;
    edge when not UseCase.NoCase and a_BledQ1 do timer := 0.0 goto Wait1;
  location Wait1:
    edge b_reset_B.toggle! when timer > 3 do timer := 0.0 goto Wait2;
  location Wait2:
    edge b_reset_B.toggle! when timer > 1 goto Init;
end
group Const:
  group Box:
    alg int[40..40] Size = 40;
    const Point StartPos = (1360.0, 211.0);
    const Point LiftPos = (1182.9, 361.0);
    const Rectangle StartBounds = (StartPos[x], StartPos[y], 40.0, 23.0);
    const Rectangle StartThickBounds = (StartPos[x], StartPos[y] + 23.0 * 0.2, 40.0, 23.0 * 1.2);
    const int[273..273] BufferY = 273;
  end
  group Lift:
    const int[133..133] MaxHeight = 133;
  end
  group Sensors:
    const Rectangle HeightBounds = (1187.0, 210.0, 36.0, 28.0);
    const Rectangle CapSensorBounds = (1184.0, 358.0, 39.0, 26.0);
    const Rectangle EntrySensorBounds = (916.0, 257.0, 11.0, 45.0);
    const Rectangle AtSepSensorBounds = (717.0, 260.0, 10.0, 41.0);
    const Rectangle ExitSensorBounds = (632.0, 256.0, 10.0, 44.0);
    const Rectangle LeftBlockBounds = (600.0, 275.0, 1.0, 50.0);
    const Rectangle RightBlockBounds = (620.0, 275.0, 1.0, 50.0);
    const string offColor = "#004455";
    const string onColor = "#00ffcc";
  end
  group Buttons:
  end
end
svgout id "Platform" attr "transform" value fmt("translate(0, %f)", Lift.y) file "../SystemSVG.svg";
svgout id "a_pusher" attr "transform" value fmt("translate(%f, 0)", Pusher.x) file "../SystemSVG.svg";
svgout id "time" text value round(time) file "../SystemSVG.svg";
svgout id "a_height_head" attr "transform" value fmt("translate(0, %f)", HeightSensor.y) file "../SystemSVG.svg";
svgout id "Rotator" attr "transform" value fmt("rotate(%f,12.5,0)", Arm.armRot) file "../SystemSVG.svg";
svgout id "Holder" attr "transform" value fmt("rotate(%f,6.25,0)", -Arm.armRot) file "../SystemSVG.svg";
svgout id "Air" attr "opacity" value if a_airslide: 1 else 0 end file "../SystemSVG.svg";
svgout id "s_q1" attr "fill" value if a_TledQ1: "yellow" else "grey" end file "../SystemSVG.svg";
svgout id "s_q2" attr "fill" value if a_TledQ2: "yellow" else "grey" end file "../SystemSVG.svg";
svgout id "a_separator" attr "transform" value fmt("translate(%f,0)", if a_separator: -10.0 else -25.0 end) file "../SystemSVG.svg";
svgout id "key" attr "transform" value fmt("rotate(%f,10,10)", if s_Tautoswitch: 90.0 else 0.0 end) file "../SystemSVG.svg";
svgout id "key-2" attr "transform" value fmt("rotate(%f,10,10)", if s_Bautoswitch: 90.0 else 0.0 end) file "../SystemSVG.svg";
svgout id "s_systemMode" text value fmt("System State: %s", SysState.state) file "../SystemSVG.svg";
