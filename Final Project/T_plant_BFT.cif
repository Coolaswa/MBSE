/** Authors of this document:
 *  L.J. Buijs       0959903
 *  M.P. Favier      0951737
 *  M.W. Timmermans  0956838
 */

import "TB_SVG_BFT.cif";
import "TB_Defs_BFT.cif";
import "TB_SVGConstants_BFT.cif";
import "TB_box_BFT.cif";

// Actuators
input bool a_elevator_up;
input bool a_elevator_down;
input bool a_pusher;
input bool a_testingready;

// Sensors
alg bool s_Tautoswitch = b_autoManualSwitch.Pressed;
alg bool s_pusher = Pusher.Extending and Pusher.x < -35 and not b_s_pusher.Pressed;
alg bool s_elevator_up = Lift.y <= -Const.Lift.MaxHeight and not b_s_lift_up.Pressed;
alg bool s_elevator_down = Lift.y >= 0 and not b_s_lift_down.Pressed;
alg bool s_capacitive = boxInLift != -1;
alg bool s_reflective = Arm.armRot < 130;
alg bool s_productheight = HeightSensor.isActive;
alg bool s_Tstartbutton = b_start.state;
alg bool s_Tstopbutton = b_stop.state;
alg bool s_Tresetbutton = b_reset.Pressed;
alg bool s_optical = (boxInLift != -1 and BoxUpdater.data[boxInLift][color] != "black");
alg bool s_Bstartbutton  = b_start_B.Pressed;
alg bool s_Tinitialized = true;
alg bool s_Binitialized = true;

alg int boxInLift = RectRectColl((Const.Sensors.CapSensorBounds[x],
                        Const.Sensors.CapSensorBounds[y] + Lift.y,
                        Const.Sensors.CapSensorBounds[width],
                        Const.Sensors.CapSensorBounds[height]), BoxUpdater.data);

// Events
event BoxData spawn_new_block;
event productRejected;
event void pusher_activated;

// Button definitions
b_start_B: Button(false);
b_start_B_svg: Button_svg(b_start_B.clicked, "start_B", "green", "grey",  b_start_B.state);
b_startB_list: Listener(b_start_B);

b_start: Button(false);
b_start_svg: Button_svg(b_start.clicked, "start", "green", "grey",  b_start.state);
b_start_list: Listener(b_start);

b_reset: Button(false);
b_reset_svg: Button_svg(b_reset.clicked, "b_reset", "yellow", "grey", b_reset.state);
b_reset_list: Listener(b_reset);

b_stop: Button(true);
stop_svg: Button_svg(b_stop.clicked, "stop", "red", "grey",  b_stop.state);
b_stop_list: Listener(b_stop);

b_s_lift_up: Button(false);
svg_s_lift_up: ClickLed_svg("s_lift_up", Const.Sensors.onColor, Const.Sensors.offColor, s_elevator_up, b_s_lift_up);
b_liftup_list: Listener(b_s_lift_up);

b_s_lift_down: Button(false);
svg_s_lift_down:ClickLed_svg("s_lift_down",Const.Sensors.onColor,Const.Sensors.offColor,s_elevator_down,b_s_lift_down);
b_liftdown_list: Listener(b_s_lift_down);

b_color: Button(false);
svg_b_color: Switch_svg(b_color.clicked, b_color.state);
b_color_list: Listener(b_color);

b_height: Button(false);
svg_b_height: Switch2_svg(b_height.clicked);
b_height_list: Listener(b_height);

b_spawn: Button(false);
svg_b_spawn: Button_svg(b_spawn.clicked, "b_spawn", "yellow", "grey", b_spawn.state);
b_spawn_list: Listener(b_spawn);

b_autoManualSwitch: Button(false);
svg_b_autoManualSwitch: Button_svg(b_autoManualSwitch.clicked, "key", "yellow", "grey", b_autoManualSwitch.state);
b_autoManualSwitch_list: Listener(b_autoManualSwitch);

b_s_pusher: Button(false);
svg_s_pusher: ClickLed_svg("s_pusher", Const.Sensors.onColor, Const.Sensors.offColor, s_pusher, b_s_pusher);
b_pusher_list: Listener(b_s_pusher);

b_case1: Button(false);
b_case1_svg: Button_svg(b_case1.clicked, "b_case1", "yellow", "grey", b_case1.state);
b_case1_list: Listener(b_case1);
b_case2: Button(false);
b_case2_svg: Button_svg(b_case2.clicked, "b_case2", "yellow", "grey", b_case2.state);
b_case2_list: Listener(b_case2);
b_case3: Button(false);
b_case3_svg: Button_svg(b_case3.clicked, "b_case3", "yellow", "grey", b_case3.state);
b_case3_list: Listener(b_case3);

// Svg related variables
svg_s_height: LED_svg("s_height", Const.Sensors.onColor, Const.Sensors.offColor, HeightSensor.isActive);
svg_s_height2: LED_svg("s_height2", "red", "grey", HeightSensor.isActive);
svg_s_capacitive: LED_svg("s_capacitive", Const.Sensors.onColor, Const.Sensors.offColor, s_capacitive);
svg_s_reflective: LED_svg("s_reflective", Const.Sensors.onColor, Const.Sensors.offColor, s_reflective);
svg_s_optical: LED_svg("s_optical", Const.Sensors.onColor, Const.Sensors.offColor, s_optical);

svg_a_conv: LED_svg("b_conveyor", "yellow", "grey", a_conveyer);
svg_a_testingrdy: LED_svg("b_testingready", "yellow", "grey", a_testingready);
svg_a_elvup: LED_svg("a_lift_up", "yellow", "grey", a_elevator_up);
svg_a_elvdown: LED_svg("a_lift_down", "yellow", "grey", a_elevator_down);
svg_a_push: LED_svg("b_pusher", "yellow", "grey", a_pusher);
svg_a_air: LED_svg("b_airslide", "yellow", "grey", a_airslide);

// Responsible for keeping track of the state of the system
automaton SysState:
    alg string state;
    location Off:
        equation state = "Off";
        initial;
        edge when s_Tstartbutton goto WaitForRelease;
    location WaitForRelease:
        equation state = "Off";
        edge when not s_Tstartbutton goto On;
    location On:
        equation state = if s_Tautoswitch: "Auto" else "Manual" end;
        edge when s_Tstopbutton goto WaitForStopRelease;
    location WaitForStopRelease:
        equation state = if s_Tautoswitch: "Auto" else "Manual" end;
        edge when not s_Tstopbutton goto Off;
end

// Placeholder for the data of the boxes
automaton BoxUpdater:
    alg list[10] BoxData data;
    alg list[10] Rectangle rects;
    location:
        equation data = [
         ((box1.x,box1.y,40,23), box1.color, box1.isThick, box1.rotation),
         ((box2.x,box2.y,40,23), box2.color, box2.isThick, box2.rotation),
         ((box3.x,box3.y,40,23), box3.color, box3.isThick, box3.rotation),
         ((box4.x,box4.y,40,23), box4.color, box4.isThick, box4.rotation),
         ((box5.x,box5.y,40,23), box5.color, box5.isThick, box5.rotation),
         ((box6.x,box6.y,40,23), box6.color, box6.isThick, box6.rotation),
         ((box7.x,box7.y,40,23), box7.color, box7.isThick, box7.rotation),
         ((box8.x,box8.y,40,23), box8.color, box8.isThick, box8.rotation),
         ((box9.x,box9.y,40,23), box9.color, box9.isThick, box9.rotation),
         ((box10.x,box10.y,40,23), box10.color, box10.isThick, box10.rotation)];
         equation rects = [
         (box1.x,box1.y,40,23),
         (box2.x,box2.y,40,23),
         (box3.x,box3.y,40,23),
         (box4.x,box4.y,40,23),
         (box5.x,box5.y,40,23),
         (box6.x,box6.y,40,23),
         (box7.x,box7.y,40,23),
         (box8.x,box8.y,40,23),
         (box9.x,box9.y,40,23),
         (box10.x,box10.y,40,23)];
        initial;
end

// Responsible for broadcasting when a product has entered the rejectbuffer
automaton RejectBuffer:
     event void preRejectEnter;
     location Await:
        initial;
        edge preRejectEnter? goto Send;
     location Send:
        edge productRejected goto Await;
end

// Responsible for controlling the lift based on the actuators
automaton Lift:
    const real maxSpeed = 80;
    alg real speed;
    cont y der speed;
    alg bool liftAtTop = Lift.y <= -Const.Lift.MaxHeight;
    alg bool liftAtBot = Lift.y >= 0;
    location Up:
        equation speed = -maxSpeed;
        edge when not a_elevator_up goto Stop;
        edge when liftAtTop goto Stop;
    location Stop:
        initial;
        equation speed = 0;
        edge when a_elevator_up and not liftAtTop goto Up;
        edge when a_elevator_down and not liftAtBot  goto Down;
    location Down:
        equation speed = maxSpeed;
        edge when not a_elevator_down goto Stop;
        edge when liftAtBot goto Stop;
end

// Responsible for controlling the pusher based on the state of the actuators
automaton Pusher:
    alg real speed;
    cont x der speed;
    alg bool pusherExtend = Pusher.Extending and Pusher.x < -35;
    location Extending:
        equation speed = if not pusherExtend: -boxSpeed else 0 end;
        edge when not a_pusher goto Retracting;
    location Retracting:
        initial;
        equation speed = if x < 0: boxSpeed else 0 end;
        edge pusher_activated! when a_pusher goto Extending;
end

// Responsible for controlling the height sensor
automaton HeightSensor:
    alg int boxI = RectRectColl(Const.Sensors.HeightBounds, BoxUpdater.data);
    alg bool isActive =  not ((boxI != -1) and BoxUpdater.data[boxI][thick]);
    cont y;
    location:
        equation y' = if boxI != -1: Lift.speed elif y < 0: 10 else 0 end;
        initial;
end

// Responsible for simulating the arm
automaton Arm:
    cont armRot = 180 der armSpeed;
    disc real armSpeed = 0;
    location Waiting:
        initial;
        edge spawn_new_block when a_testingready do armSpeed := -100 goto Placing;
    location Returning:
        edge when armRot > 180 do armSpeed := 0 goto Waiting;
    location Placing:
        edge when armRot < 99 do armSpeed := 100 goto Returning;
end

// Responsible for spawning new blocks
automaton Factory:
    monitor b_spawn.clicked;
    disc string boxColor;
    disc bool isBlack;
    disc bool isThick;

    alg string boxColorMan = if b_color.Released: "black" else "red" end;
    alg string boxColorAuto = if isBlack: "black" else "red" end;
    alg bool isThickMan = svg_b_height.state = 0;

    disc dist bool thickDistrC1 = bernoulli(0);
    disc dist bool thickDistrC2 = bernoulli(0.4);
    disc dist bool thickDistrC3 = bernoulli(0.1);
    disc dist bool blackDistrC1 = bernoulli(0);
    disc dist bool blackDistrC2 = bernoulli(0.4);
    disc dist bool blackDistrC3 = bernoulli(0.1);

    cont timer der -1;
    location Waiting:
        initial;
        edge b_spawn.clicked when a_testingready and UseCase.NoCase do (boxColor, isThick) := (boxColorMan, isThickMan) goto SpawnBlock;
        edge when a_testingready and timer < 0 and UseCase.Case1
                do (isThick, thickDistrC1) := sample thickDistrC1, (isBlack, blackDistrC1) := sample blackDistrC1 goto Inter;
        edge when a_testingready and timer < 0 and UseCase.Case2
                do (isThick, thickDistrC2) := sample thickDistrC2, (isBlack, blackDistrC2) := sample blackDistrC2 goto Inter;
        edge when a_testingready and timer < 0 and UseCase.Case3
                do (isThick, thickDistrC3) := sample thickDistrC3, (isBlack, blackDistrC3) := sample blackDistrC1 goto Inter;
    location Inter:
        edge do boxColor := boxColorAuto goto SpawnBlock;
    location SpawnBlock:
        edge spawn_new_block! (Const.Box.StartThickBounds, boxColor, isThick,0) when isThick goto Post;
        edge spawn_new_block! (Const.Box.StartBounds, boxColor, isThick,0) when not isThick goto Post;
    location Post:
        edge do timer := 3 goto Waiting;
end

// Responsible for keeping track which use case is active
automaton UseCase:
    location Case1:
        initial;
        edge when b_case1.Released goto NoCase;
    location Case2:
        edge when b_case2.Released goto NoCase;
    location Case3:
        edge when b_case3.Released goto NoCase;
    location NoCase:
        edge when b_case1.Pressed goto Case1;
        edge when b_case2.Pressed goto Case2;
        edge when b_case3.Pressed goto Case3;
end

// Responsible for automatically pressing reset after the buffer is full
automaton Q1ResetPresser:
    cont timer der 1;
    location Init:
        initial;
        edge when not UseCase.NoCase and a_TledQ1 do timer := 0 goto Wait1;
    location Wait1:
        edge b_reset.toggle! when timer > 3 do timer := 0 goto Wait2;
    location Wait2:
        edge b_reset.toggle! when timer > 1 goto Init;
end

// Responsible for removing products when in use case 3
automaton ProdRemoval:
    cont timer der -1;
    location Init:
        initial;
        edge when UseCase.Case3 goto Stage1;
    location Stage1:
        edge when not UseCase.Case3 goto Init;
        edge box1.clicked! when box1.OnAirslide do timer := 3 goto Stage2;
        edge box2.clicked! when box2.OnAirslide do timer := 2 goto Stage2;
        edge box3.clicked! when box3.OnAirslide do timer := 1 goto Stage2;
        edge box4.clicked! when box4.OnAirslide do timer := 1 goto Stage2;
        edge box5.clicked! when box5.OnAirslide do timer := 1 goto Stage2;
        edge box6.clicked! when box6.OnAirslide do timer := 1 goto Stage2;
        edge box7.clicked! when box7.OnAirslide do timer := 1 goto Stage2;
        edge box8.clicked! when box8.OnAirslide do timer := 1 goto Stage2;
        edge box9.clicked! when box9.OnAirslide do timer := 1 goto Stage2;
        edge box10.clicked! when box10.OnAirslide do timer := 1 goto Stage2;
    location Stage2:
        edge when not UseCase.Case3 goto Init;
        edge box1.clicked! when box1.OnBufferMoving and timer < 0 goto Stage3;
        edge box2.clicked! when box2.OnBufferMoving and timer < 0 goto Stage3;
        edge box3.clicked! when box3.OnBufferMoving and timer < 0 goto Stage3;
        edge box4.clicked! when box4.OnBufferMoving and timer < 0 goto Stage3;
        edge box5.clicked! when box5.OnBufferMoving and timer < 0 goto Stage3;
    location Stage3:
        edge when not UseCase.Case3 goto Init;
        edge box1.clicked! when box1.InSeperatorWaiting goto Stage1;
        edge box2.clicked! when box2.InSeperatorWaiting goto Stage1;
        edge box3.clicked! when box3.InSeperatorWaiting goto Stage1;
        edge box4.clicked! when box4.InSeperatorWaiting goto Stage1;
        edge box5.clicked! when box5.InSeperatorWaiting goto Stage1;
end

// Responsible for sensor malfunction when in use case 3
automaton SensorMalfunctioner:
    cont timer der -1;
    location Init:
        initial;
        edge when UseCase.Case3 goto Stage1;
    location Stage1:
        edge when not UseCase.Case3 goto Init;
        edge b_s_lift_up.toggle! when Lift.Up do timer := 8 goto Stage2;
    location Stage2:
        edge b_s_lift_up.toggle! when timer < 0 goto Stage3;
    location Stage3:
        edge b_s_lift_down.toggle! when Lift.Down do timer := 8 goto Stage4;
    location Stage4:
        edge b_s_lift_down.toggle! when timer < 0 do timer := 12 goto Stage5;
    location Stage5:
        edge b_s_pusher.toggle! when timer < 0 do timer := 10 goto Stage6;
    location Stage6:
        edge b_s_pusher.toggle! when timer < 0 do timer := 25 goto Delay;
    location Delay:
        edge when timer < 0 goto Init;
end

// Responsible for pressing start when the lift is malfunctioning
automaton StartAutoPresser:
    cont timer der -1;
    location Init:
        initial;
        edge when a_TledQ2 and not UseCase.NoCase do timer := 2 goto PressStart;
    location PressStart:
        edge b_start.toggle! when timer < 0 do timer := 0.5 goto ReleaseStart;
    location ReleaseStart:
        edge b_start.toggle! when timer < 0 goto Init;
end

// Responsible for fixing the sensors when start is pressed
automaton FixSensorsWhenStart:
    location Init:
        initial;
        edge when s_Tstartbutton goto WaitForRelease;
    location WaitForRelease:
        edge when not s_Tstartbutton goto FixLiftUpSensor;
    location FixLiftUpSensor:
        edge b_s_lift_up.toggle! when b_s_lift_up.Pressed goto FixLiftDownSensor;
        edge when not b_s_lift_up.Pressed goto FixLiftDownSensor;
    location FixLiftDownSensor:
        edge b_s_lift_down.toggle! when b_s_lift_down.Pressed goto FixPusher;
        edge when not b_s_lift_up.Pressed goto FixPusher;
    location FixPusher:
        edge b_s_pusher.toggle! when b_s_pusher.Pressed goto Init;
        edge when not b_s_pusher.Pressed goto Init;
end
