import "TB_SVG_BFT.cif";
import "TB_Defs_BFT.cif";
import "TB_SVGConstants_BFT.cif";
import "TB_box_BFT.cif";

input bool a_conveyer;
input bool a_separator;
input bool a_BledQ1, a_BledQ2;
alg bool s_Bautoswitch = b_BautoManualSwitch.Pressed;

alg bool s_product = EntrySensor.isActive or b_BS01.Pressed;
alg bool s_atseparator = AtSepSensor.isActive;
alg bool s_atexit = ExitSensor.isActive;
alg bool s_processingbusy = ProcessingBusySensor.On or s_Bautoswitch;

b_BS01: Button(false);
svg_b_BS01: Button_svg(b_BS01.clicked, "BS01", "yellow", "grey", b_BS01.Pressed);
svg_b_i_BS01: Button_svg(b_BS01.clicked, "i_BS01", "red", "grey", s_product);
svg_b_i_BS02: LED_svg("i_BS02", "red", "grey", s_atseparator);
svg_b_i_BS03: LED_svg("i_BS03", "red", "grey", s_atexit);

svg_s_product: LED_svg("s_product_entry", Const.Sensors.onColor, Const.Sensors.offColor, EntrySensor.isActive);
svg_s_atseparator: LED_svg("s_product_separator", Const.Sensors.onColor, Const.Sensors.offColor, AtSepSensor.isActive);
svg_s_atexit: LED_svg("s_product_exit", Const.Sensors.onColor, Const.Sensors.offColor, ExitSensor.isActive);
svg_s_separator_opened: LED_svg("s_separator_opened", Const.Sensors.onColor, Const.Sensors.offColor, Separator.Left);
svg_s_separator_closed: LED_svg("s_separator_closed", Const.Sensors.onColor, Const.Sensors.offColor, Separator.Right);
svg_s_Q1B: LED_svg("s_q1-7", "yellow", "grey", a_BledQ1);
svg_s_Q2B: LED_svg("s_q2-5", "yellow", "grey", a_BledQ2);

b_processing: Button(false);
svg_b_processing: Button_svg(b_processing.clicked, "s_processing_busy", "yellow", "grey", s_processingbusy);

b_conveyer: Button(false);
svg_b_conveyer: Button_svg(b_conveyer.clicked, "b_conveyor", "yellow", "grey", b_conveyer.state);

svg_conv: Conveyer_svg(1, Belt.wheelRotation);

b_BautoManualSwitch: Button(false);
svg_b_BautoManualSwitch: Button_svg(b_BautoManualSwitch.clicked, "key-2", "yellow", "grey", b_autoManualSwitch.state);

group AtSepSensor:
	alg int boxI = RectRectColl((Const.Sensors.AtSepSensorBounds[x],
	 						    Const.Sensors.AtSepSensorBounds[y],
	  							Const.Sensors.AtSepSensorBounds[width],
	   							Const.Sensors.AtSepSensorBounds[height]), BoxUpdater.data);
	alg bool isActive =  (boxI != -1);
end

group EntrySensor:
	alg int boxI = RectRectColl((Const.Sensors.EntrySensorBounds[x],
	 						    Const.Sensors.EntrySensorBounds[y],
	  							Const.Sensors.EntrySensorBounds[width],
	   							Const.Sensors.EntrySensorBounds[height]), BoxUpdater.data);
	alg bool isActive =  (boxI != -1);
end

group ExitSensor:
	alg int boxI = RectRectColl((Const.Sensors.ExitSensorBounds[x],
	 						    Const.Sensors.ExitSensorBounds[y],
	  							Const.Sensors.ExitSensorBounds[width],
	   							Const.Sensors.ExitSensorBounds[height]), BoxUpdater.data);
	alg bool isActive =  (boxI != -1);
end

automaton ProcessingBusySensor:
    cont timer der -1;
	location On:
		edge when UseCase.NoCase goto Off;
        edge when UseCase.Case1 and timer < 0 do timer := 3 goto Off;
        edge when UseCase.Case2 and timer < 0 do timer := 3 goto Off;
        edge when UseCase.Case3 and timer < 0 do timer := 3 goto Off;
	location Off:
        initial;
        edge when UseCase.Case1 and timer < 0 do timer := 10 goto On;
        edge when UseCase.Case2 and timer < 0 do timer := 3 goto On;
        edge when UseCase.Case3 and timer < 0 do timer := 3 goto On;
end


automaton Belt:
    cont wheelRotation der 3*Belt.speed;
	alg real speed;
	cont x der speed;
	location Moving:
		equation speed = -80;
		edge when not a_conveyer goto Standstill;
	location Standstill:
		initial;
		equation speed = 0;
		edge when a_conveyer goto Moving;
end

automaton Separator:	//Separator needs to turn/rotate when going from left to right, to be added
    location Right:
        edge when not a_separator goto Left;
    location Left:
        initial;
        edge when a_separator goto Right;
end

/*automaton Q2ResetPresser:
    cont timer der 1;
    location Init:
        initial;
        edge when not UseCase.NoCase and a_TledQ2 do timer := 0 goto Wait1;
    location Wait1:
        edge b_reset.toggle! when timer > 3 do timer := 0 goto Wait2;
    location Wait2:
        edge b_reset.toggle! when timer > 1 goto Init;
end*/

