import "TB_SVG_BFT.cif";
import "TB_Defs_BFT.cif";
import "TB_SVGConstants_BFT.cif";
import "TB_box_BFT.cif";


input bool a_conveyer;
input bool a_separator;

alg bool s_product = EntrySensor.isActive;
alg bool s_atseparator = AtSepSensor.isActive;
alg bool s_atexit = ExitSensor.isActive;
alg bool s_processingbusy = ProcessingBusySensor.On;

event ProcessingBusyClicked;
event ConveyerClicked;

svg_s_product: Button_svg(dummyEvent, "s_product_entry", "yellow", "grey", EntrySensor.isActive);
svg_s_atseparator: Button_svg(dummyEvent, "s_product_separator", "yellow", "grey", AtSepSensor.isActive);
svg_s_atexit: Button_svg(dummyEvent, "s_product_exit", "yellow", "grey", ExitSensor.isActive);
svg_s_separator_opened: Button_svg(dummyEvent, "s_separator_opened", "yellow", "grey", Separator.Left);
svg_s_separator_closed: Button_svg(dummyEvent, "s_separator_closed", "yellow", "grey", Separator.Right);

b_processing: Button(ProcessingBusyClicked);
svg_b_processing: Button_svg(ProcessingBusyClicked, "s_processing_busy", "yellow", "grey", b_processing.state);

b_conveyer: Button(ConveyerClicked);
svg_b_conveyer: Button_svg(ConveyerClicked, "b_conveyor", "yellow", "grey", b_conveyer.state);



automaton def Conveyor():
	//event turnOn, turnOff;
	//event toggle;
	cont wheelRotation der 3*Belt.speed;
	alg real wheelSpeed;
	location On:

		equation wheelSpeed = Belt.speed;
		edge when Belt.Standstill goto Off;
	location Off:
		initial;
		equation wheelSpeed = 0;
		edge when Belt.Moving goto On;
end

group AtSepSensor:
	alg int boxI = RectRectColl((Const.Sensors.AtSepSensorBounds[x],
	 						    Const.Sensors.AtSepSensorBounds[y],
	  							Const.Sensors.AtSepSensorBounds[width],
	   							Const.Sensors.AtSepSensorBounds[height]), BoxUpdater.data);
	alg bool isActive =  (boxI != -1);
end

group EntrySensor:
	alg int boxI = RectRectColl((Const.Sensors.EntrySensorBounds[x],
	 						    Const.Sensors.EntrySensorBounds[y],
	  							Const.Sensors.EntrySensorBounds[width],
	   							Const.Sensors.EntrySensorBounds[height]), BoxUpdater.data);
	alg bool isActive =  (boxI != -1);
end

group ExitSensor:
	alg int boxI = RectRectColl((Const.Sensors.ExitSensorBounds[x],
	 						    Const.Sensors.ExitSensorBounds[y],
	  							Const.Sensors.ExitSensorBounds[width],
	   							Const.Sensors.ExitSensorBounds[height]), BoxUpdater.data);
	alg bool isActive =  (boxI != -1);
end

automaton ProcessingBusySensor: //(Press Button)
	location On:
		initial;
		edge when b_processing.Pressed goto Waiting;
	location Waiting:
		edge when b_processing.Released goto Off;
	location Off:
		edge when ExitSensor.isActive goto On;
end


automaton Belt:
	alg real speed;
	cont x der speed;
	location Moving:
		equation speed = -50;
		edge when not a_conveyer goto Standstill;
	location Standstill:
		initial;
		equation speed = 0;
		edge when a_conveyer goto Moving;
end

automaton Separator:	//Separator needs to turn/rotate when going from left to right, to be added
	location Right:
		edge when not a_separator goto Left;
	location Left:
		initial;
		edge when a_separator goto Right;
end

	automaton CountFive2:			//Keeps track of how many products are on the belt.
		alg real count;


		location Zero: 				//when CountFive = 5, stops the pusher; see control
			initial;
			equation count = 0;
			edge when s_product goto OneActiveEntry;
		location ZeroActiveExit:
			equation count = 0;
			edge when not s_atexit goto Zero;

		location OneActiveEntry:
			equation count = 1;
			edge when not s_product goto One;
		location One:
			equation count = 1;
			edge when s_atexit goto ZeroActiveExit;
			edge when s_product goto TwoActiveEntry;
		location OneActiveExit:
			equation count = 1;
			edge when not s_atexit goto One;

		location TwoActiveEntry:
			equation count = 2;
			edge when not s_product goto Two;
		location Two:
			equation count = 2;
			edge when s_atexit goto OneActiveExit;
			edge when s_product goto ThreeActiveEntry;
		location TwoActiveExit:
			equation count = 2;
			edge when not s_atexit goto Two;

		location ThreeActiveEntry:
			equation count = 3;
			edge when not s_product goto Three;
		location Three:
			equation count = 3;
			edge when s_atexit goto TwoActiveExit;
			edge when s_product goto FourActiveEntry;
		location ThreeActiveExit:
			equation count = 3;
			edge when not s_atexit goto Three;

		location FourActiveEntry:
			equation count = 4;
			edge when not s_product goto Four;
		location Four:
			equation count = 4;
			edge when s_atexit goto ThreeActiveExit;
			edge when s_product goto Five;
		location FourActiveExit:
			equation count = 4;
			edge when not s_atexit goto Four;

		location Five:
			equation count = 5;
			edge when s_atexit goto FourActiveExit;
	end



